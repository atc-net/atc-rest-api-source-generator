// <auto-generated />
import axios from 'axios';
import type { AxiosInstance, AxiosResponse, InternalAxiosRequestConfig } from 'axios';
import { ApiError } from '../errors/ApiError';
import { ValidationError } from '../errors/ValidationError';
import type { ApiResult } from '../types/ApiResult';

export type AxiosRequestInterceptor = (config: InternalAxiosRequestConfig) => InternalAxiosRequestConfig | Promise<InternalAxiosRequestConfig>;
export type AxiosResponseInterceptor = (response: AxiosResponse) => AxiosResponse | Promise<AxiosResponse>;

export interface ApiClientOptions {
  getAccessToken?: () => string | Promise<string>;
  defaultHeaders?: Record<string, string>;
  requestInterceptors?: AxiosRequestInterceptor[];
  responseInterceptors?: AxiosResponseInterceptor[];
}

export interface RequestOptions {
  body?: unknown;
  query?: Record<string, string | number | boolean | undefined>;
  headers?: Record<string, string>;
  signal?: AbortSignal;
  responseType?: 'json' | 'blob';
}

export class ApiClient {
  private readonly baseUrl: string;
  private readonly client: AxiosInstance;
  private readonly options: ApiClientOptions;

  constructor(baseUrl: string, options?: ApiClientOptions) {
    this.baseUrl = baseUrl.replace(/\/+$/, '');
    this.options = options ?? {};
    this.client = axios.create({
      baseURL: this.baseUrl,
      validateStatus: () => true,
    });

    if (this.options.defaultHeaders) {
      for (const [key, value] of Object.entries(this.options.defaultHeaders)) {
        this.client.defaults.headers.common[key] = value;
      }
    }

    if (this.options.getAccessToken) {
      const getToken = this.options.getAccessToken;
      this.client.interceptors.request.use(async (config) => {
        const token = await getToken();
        config.headers.Authorization = `Bearer ${token}`;
        return config;
      });
    }

    for (const interceptor of this.options.requestInterceptors ?? []) {
      this.client.interceptors.request.use(interceptor);
    }

    for (const interceptor of this.options.responseInterceptors ?? []) {
      this.client.interceptors.response.use(interceptor);
    }
  }

  async request<T>(method: string, path: string, options?: RequestOptions): Promise<ApiResult<T>> {
    let data: unknown;
    const headers: Record<string, string> = {};

    if (options?.body !== undefined) {
      if (options.body instanceof FormData) {
        data = options.body;
      } else if (options.body instanceof Blob) {
        headers['Content-Type'] = 'application/octet-stream';
        data = options.body;
      } else {
        headers['Content-Type'] = 'application/json';
        data = options.body;
      }
    }

    if (options?.headers) {
      Object.assign(headers, options.headers);
    }

    const response = await this.client.request<T>({
      method,
      url: path,
      data,
      params: options?.query,
      headers,
      signal: options?.signal,
      responseType: options?.responseType === 'blob' ? 'blob' : 'json',
    });

    return this.handleResponse<T>(response);
  }

  // Streaming uses native fetch — Axios doesn't natively support ReadableStream iteration.
  // Auth and default headers are applied manually; Axios interceptors do not apply to streaming requests.
  async *requestStream<T>(method: string, path: string, options?: RequestOptions): AsyncGenerator<T> {
    const url = this.buildUrl(path, options?.query);
    const headers = new Headers(this.options.defaultHeaders);

    if (this.options.getAccessToken) {
      const token = await this.options.getAccessToken();
      headers.set('Authorization', `Bearer ${token}`);
    }

    if (options?.headers) {
      for (const [key, value] of Object.entries(options.headers)) {
        headers.set(key, value);
      }
    }

    const response = await fetch(url, {
      method,
      headers,
      signal: options?.signal,
    });

    if (!response.ok) {
      throw new ApiError(response.status, response.statusText, 'Stream request failed');
    }

    const reader = response.body?.getReader();
    if (!reader) {
      throw new ApiError(0, 'NoBody', 'Response body is empty');
    }

    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() ?? '';

        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.length === 0) continue;
          yield JSON.parse(trimmed) as T;
        }
      }

      if (buffer.trim().length > 0) {
        yield JSON.parse(buffer.trim()) as T;
      }
    } finally {
      reader.releaseLock();
    }
  }

  private buildUrl(path: string, query?: Record<string, string | number | boolean | undefined>): string {
    const url = new URL(`${this.baseUrl}${path}`);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        if (value !== undefined) {
          url.searchParams.set(key, String(value));
        }
      }
    }
    return url.toString();
  }

  private handleResponse<T>(response: AxiosResponse<T>): ApiResult<T> {
    if (response.status === 204) {
      return { status: 'noContent', response };
    }

    if (response.status >= 200 && response.status < 300) {
      const status = response.status === 201 ? 'created' as const : 'ok' as const;
      return { status, data: response.data, response };
    }

    const errorBody = response.data as Record<string, unknown> | null;
    const message = (errorBody?.title ?? errorBody?.message ?? response.statusText) as string;

    if (response.status === 400 && errorBody?.errors) {
      return {
        status: 'badRequest',
        error: new ValidationError(
          response.status, response.statusText, message,
          errorBody.errors as Record<string, string[]>, response,
        ),
        response,
      };
    }

    const apiError = new ApiError(response.status, response.statusText, message, response);

    switch (response.status) {
      case 401:
        return { status: 'unauthorized', error: apiError, response };
      case 404:
        return { status: 'notFound', error: apiError, response };
      case 409:
        return { status: 'conflict', error: apiError, response };
      default:
        return { status: 'serverError', error: apiError, response };
    }
  }
}