// <auto-generated />
#nullable enable

using System.CodeDom.Compiler;
using Microsoft.Extensions.DependencyInjection;

using CachingHybrid.Generated.Caching;
using Microsoft.Extensions.Caching.Hybrid;

namespace CachingHybrid.Generated.Caching;

/// <summary>
/// Extension methods for configuring API HybridCache policies.
/// </summary>
[GeneratedCode("Atc.Rest.Api.SourceGenerator", "1.0.0")]
public static class HybridCachingServiceCollectionExtensions
{
    /// <summary>
    /// Registers HybridCache with configured entry options for the API based on OpenAPI extensions.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="configureOptions">Optional action to configure HybridCache options.</param>
    /// <returns>The service collection for method chaining.</returns>
    public static IServiceCollection AddApiCaching(
        this IServiceCollection services,
        Action<HybridCacheOptions>? configureOptions = null)
    {
        services.AddHybridCache(options =>
        {
            // Configure default options
            options.DefaultEntryOptions = new HybridCacheEntryOptions
            {
                Expiration = TimeSpan.FromSeconds(300),
            };

            // Apply custom configuration if provided
            configureOptions?.Invoke(options);
        });

        return services;
    }

    /// <summary>
    /// Gets the HybridCacheEntryOptions for a specific cache policy.
    /// </summary>
    /// <param name="policyName">The cache policy name.</param>
    /// <returns>The configured HybridCacheEntryOptions, or default options if policy not found.</returns>
    public static HybridCacheEntryOptions GetCacheEntryOptions(string policyName)
        => policyName switch
        {
            CachePolicies.Sessions => new HybridCacheEntryOptions
            {
                Expiration = TimeSpan.FromSeconds(300),
                Flags = HybridCacheEntryFlags.DisableLocalCache,
            },
            CachePolicies.Settings => new HybridCacheEntryOptions
            {
                Expiration = TimeSpan.FromSeconds(300),
                Flags = HybridCacheEntryFlags.DisableDistributedCache,
            },
            CachePolicies.UserDetail => new HybridCacheEntryOptions
            {
                Expiration = TimeSpan.FromSeconds(300),
            },
            CachePolicies.Users => new HybridCacheEntryOptions
            {
                Expiration = TimeSpan.FromSeconds(300),
            },
            _ => new HybridCacheEntryOptions
            {
                Expiration = TimeSpan.FromSeconds(300),
            },
        };

    /// <summary>
    /// Gets the cache tags for a specific cache policy.
    /// </summary>
    /// <param name="policyName">The cache policy name.</param>
    /// <returns>The cache tags for the policy, or an empty array if policy not found.</returns>
    public static string[] GetCacheTags(string policyName)
        => policyName switch
        {
            CachePolicies.Sessions => ["sessions"],
            CachePolicies.Settings => ["settings"],
            CachePolicies.UserDetail => ["user-detail", "users"],
            CachePolicies.Users => ["users"],
            _ => [],
        };

    /// <summary>
    /// Generates a cache key based on policy configuration and request parameters.
    /// </summary>
    /// <param name="policyName">The cache policy name.</param>
    /// <param name="baseKey">The base cache key (e.g., operation name).</param>
    /// <param name="queryParams">Optional query parameters to include in the key.</param>
    /// <param name="headers">Optional headers to include in the key.</param>
    /// <returns>The generated cache key.</returns>
    public static string GenerateCacheKey(
        string policyName,
        string baseKey,
        IDictionary<string, string>? queryParams = null,
        IDictionary<string, string>? headers = null)
    {
        var keyBuilder = new System.Text.StringBuilder();

        // Add key prefix if configured
        var prefix = GetKeyPrefix(policyName);
        if (!string.IsNullOrEmpty(prefix))
        {
            keyBuilder.Append(prefix);
            keyBuilder.Append(':');
        }

        keyBuilder.Append(baseKey);

        // Add vary-by-query parameters
        var varyByQuery = GetVaryByQuery(policyName);
        if (varyByQuery.Length > 0 && queryParams != null)
        {
            foreach (var param in varyByQuery.OrderBy(p => p, StringComparer.Ordinal))
            {
                if (queryParams.TryGetValue(param, out var value))
                {
                    keyBuilder.Append(':');
                    keyBuilder.Append(param);
                    keyBuilder.Append('=');
                    keyBuilder.Append(value);
                }
            }
        }

        // Add vary-by-header values
        var varyByHeader = GetVaryByHeader(policyName);
        if (varyByHeader.Length > 0 && headers != null)
        {
            foreach (var header in varyByHeader.OrderBy(h => h, StringComparer.Ordinal))
            {
                if (headers.TryGetValue(header, out var value))
                {
                    keyBuilder.Append(':');
                    keyBuilder.Append(header);
                    keyBuilder.Append('=');
                    keyBuilder.Append(value);
                }
            }
        }

        return keyBuilder.ToString();
    }

    private static string[] GetVaryByQuery(string policyName)
        => policyName switch
        {
            CachePolicies.Sessions => [],
            CachePolicies.Settings => [],
            CachePolicies.UserDetail => [],
            CachePolicies.Users => ["search", "role", "limit"],
            _ => [],
        };

    private static string[] GetVaryByHeader(string policyName)
        => policyName switch
        {
            CachePolicies.Sessions => ["Authorization"],
            CachePolicies.Settings => [],
            CachePolicies.UserDetail => [],
            CachePolicies.Users => [],
            _ => [],
        };

    private static string? GetKeyPrefix(string policyName)
        => policyName switch
        {
            CachePolicies.Sessions => null,
            CachePolicies.Settings => null,
            CachePolicies.UserDetail => "user",
            CachePolicies.Users => null,
            _ => null,
        };
}