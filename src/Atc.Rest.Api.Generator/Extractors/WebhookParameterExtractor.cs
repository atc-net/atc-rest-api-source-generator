// ReSharper disable InvertIf
namespace Atc.Rest.Api.Generator.Extractors;

/// <summary>
/// Extracts webhook request bodies and converts them to parameter classes.
/// </summary>
public static class WebhookParameterExtractor
{
    /// <summary>
    /// Extracts webhook parameter classes from OpenAPI document.
    /// </summary>
    /// <param name="openApiDoc">The OpenAPI document containing webhook definitions.</param>
    /// <param name="projectName">The name of the project (used for namespace).</param>
    /// <param name="systemTypeResolver">Resolver for system type conflicts.</param>
    /// <param name="includeDeprecated">Whether to include deprecated webhooks.</param>
    /// <returns>List of generated parameter class tuples (ClassName, Content).</returns>
    public static List<(string ClassName, string Content)>? Extract(
        OpenApiDocument openApiDoc,
        string projectName,
        SystemTypeConflictResolver systemTypeResolver,
        bool includeDeprecated = false)
    {
        if (openApiDoc == null)
        {
            throw new ArgumentNullException(nameof(openApiDoc));
        }

        if (!openApiDoc.HasWebhooks())
        {
            return null;
        }

        var parametersList = new List<(string ClassName, string Content)>();
        var namespaceValue = NamespaceBuilder.ForWebhookParameters(projectName);

        foreach (var (webhookName, httpMethod, operation) in openApiDoc.GetAllWebhookOperations())
        {
            // Skip deprecated webhooks if not including them
            if (!includeDeprecated && operation.Deprecated)
            {
                continue;
            }

            // Only create parameter class if webhook has a request body
            if (operation.RequestBody == null)
            {
                continue;
            }

            var result = ExtractWebhookParameters(
                webhookName,
                operation,
                openApiDoc,
                projectName,
                namespaceValue,
                systemTypeResolver);

            if (result != null)
            {
                parametersList.Add(result.Value);
            }
        }

        return parametersList.Count > 0 ? parametersList : null;
    }

    private static (string ClassName, string Content)? ExtractWebhookParameters(
        string webhookName,
        OpenApiOperation operation,
        OpenApiDocument openApiDoc,
        string projectName,
        string namespaceValue,
        SystemTypeConflictResolver systemTypeResolver)
    {
        if (operation.RequestBody?.Content == null || operation.RequestBody.Content.Count == 0)
        {
            return null;
        }

        // Get operation ID or generate from webhook name
        var operationId = operation.OperationId ?? $"On{webhookName.EnsureFirstCharacterToUpper()}";
        var className = $"{operationId.EnsureFirstCharacterToUpper()}WebhookParameters";

        // Get the schema from the request body content
        var contentType = operation.RequestBody.Content.Keys.FirstOrDefault() ?? "application/json";
        if (!operation.RequestBody.Content.TryGetValue(contentType, out var mediaType) || mediaType?.Schema == null)
        {
            return null;
        }

        var schema = mediaType.Schema;
        var resolvedSchema = schema.ResolveSchema(openApiDoc);

        if (resolvedSchema == null)
        {
            return null;
        }

        // Get the type name for the request body
        var bodyTypeName = GetBodyTypeName(schema, resolvedSchema, systemTypeResolver);
        var isRequired = operation.RequestBody.Required;

        var propertyType = isRequired ? bodyTypeName : $"{bodyTypeName}?";

        // Get the correct model usings for this webhook's schemas
        var modelUsings = PathSegmentHelper.GetWebhookModelUsings(openApiDoc, projectName, operation);

        // Generate the complete class content
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.CodeDom.Compiler;");
        sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");

        // Add model namespace usings (could be shared or segment-specific)
        foreach (var modelUsing in modelUsings)
        {
            sb.AppendLine($"using {modelUsing};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceValue};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Parameters for the {webhookName} webhook.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"[GeneratedCode(\"{GeneratorInfo.Name}\", \"{GeneratorInfo.Version}\")]");
        sb.AppendLine($"public sealed class {className}");
        sb.AppendLine("{");
        sb.AppendLine(4, "/// <summary>");
        sb.AppendLine(4, "/// The webhook payload.");
        sb.AppendLine(4, "/// </summary>");
        sb.AppendLine(4, "[FromBody]");

        if (isRequired)
        {
            sb.AppendLine(4, "[Required]");
            sb.AppendLine(4, $"public {propertyType} Payload {{ get; init; }} = default!;");
        }
        else
        {
            sb.AppendLine(4, $"public {propertyType}? Payload {{ get; init; }}");
        }

        sb.Append('}');

        return (className, sb.ToString());
    }

    private static string GetBodyTypeName(
        IOpenApiSchema schema,
        IOpenApiSchema resolvedSchema,
        SystemTypeConflictResolver systemTypeResolver)
    {
        // If it's a reference, use the reference name
        if (schema is OpenApiSchemaReference schemaRef)
        {
            var refName = schemaRef.Reference?.Id;
            if (!string.IsNullOrEmpty(refName))
            {
                return systemTypeResolver.EnsureFullNamespaceIfNeeded(refName!);
            }
        }

        // Otherwise, determine type from schema
        return resolvedSchema.ToCSharpType(isRequired: true);
    }
}