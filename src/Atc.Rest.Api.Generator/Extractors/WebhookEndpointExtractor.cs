// ReSharper disable InvertIf
namespace Atc.Rest.Api.Generator.Extractors;

/// <summary>
/// Extracts OpenAPI webhooks and converts them to endpoint registration code.
/// Webhooks in OpenAPI define how your API sends data to external systems,
/// but this generates endpoints for receiving webhook callbacks (the receiver side).
/// </summary>
public static class WebhookEndpointExtractor
{
    /// <summary>
    /// Extracts webhook endpoint registration class parameters from OpenAPI document.
    /// </summary>
    /// <param name="openApiDoc">The OpenAPI document containing webhook definitions.</param>
    /// <param name="projectName">The name of the project (used for namespace).</param>
    /// <param name="config">The server configuration (used for webhook base path).</param>
    /// <returns>ClassParameters for the webhook endpoint registration class, or null if no webhooks exist.</returns>
    public static ClassParameters? Extract(
        OpenApiDocument openApiDoc,
        string projectName,
        ServerConfig config)
    {
        if (openApiDoc == null)
        {
            throw new ArgumentNullException(nameof(openApiDoc));
        }

        if (config == null)
        {
            throw new ArgumentNullException(nameof(config));
        }

        if (!openApiDoc.HasWebhooks())
        {
            return null;
        }

        // Generate method content
        var webhookBasePath = config.WebhookBasePath ?? "/webhooks";
        var methodContent = GenerateMethodContent(openApiDoc, config.IncludeDeprecated, webhookBasePath);
        if (string.IsNullOrEmpty(methodContent))
        {
            return null;
        }

        // Build method parameters
        var methodParams = new List<ParameterBaseParameters>
        {
            new(
                Attributes: null,
                GenericTypeName: null,
                IsGenericListType: false,
                TypeName: "this IEndpointRouteBuilder",
                IsNullableType: false,
                IsReferenceType: true,
                Name: "endpoints",
                DefaultValue: null),
        };

        var methodDocParams = new Dictionary<string, string>(StringComparer.Ordinal)
        {
            { "endpoints", "The endpoint route builder." },
        };

        var method = new MethodParameters(
            DocumentationTags: new CodeDocumentationTags(
                summary: "Maps all webhook endpoints for receiving webhook callbacks.",
                parameters: methodDocParams,
                remark: $"Webhooks are registered under the {webhookBasePath} path group.",
                code: null,
                example: null,
                exceptions: null,
                @return: "The endpoint route builder for method chaining."),
            Attributes: null,
            DeclarationModifier: DeclarationModifiers.PublicStatic,
            ReturnGenericTypeName: null,
            ReturnTypeName: "IEndpointRouteBuilder",
            Name: $"Map{projectName.ToPascalCaseForDotNet()}Webhooks",
            Parameters: methodParams,
            AlwaysBreakDownParameters: false,
            UseExpressionBody: false,
            Content: methodContent);

        var headerContent = GenerateHeaderContent(projectName);

        return new ClassParameters(
            HeaderContent: headerContent,
            Namespace: NamespaceBuilder.ForWebhookEndpoints(projectName),
            DocumentationTags: new CodeDocumentationTags("Extension methods for registering webhook endpoints."),
            Attributes: new List<AttributeParameters>
            {
                new("GeneratedCode", $"\"{GeneratorInfo.Name}\", \"{GeneratorInfo.Version}\""),
            },
            DeclarationModifier: DeclarationModifiers.PublicStaticClass,
            ClassTypeName: "WebhookEndpointExtensions",
            GenericTypeName: null,
            InheritedClassTypeName: null,
            InheritedGenericClassTypeName: null,
            InheritedInterfaceTypeName: null,
            Constructors: null,
            Properties: null,
            Methods: new List<MethodParameters> { method },
            GenerateToStringMethod: false);
    }

    private static string GenerateHeaderContent(string projectName)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine("using System.CodeDom.Compiler;");
        builder.AppendLine("using System.Threading;");
        builder.AppendLine("using Microsoft.AspNetCore.Builder;");
        builder.AppendLine("using Microsoft.AspNetCore.Http;");
        builder.AppendLine("using Microsoft.AspNetCore.Mvc;");
        builder.AppendLine("using Microsoft.AspNetCore.Routing;");
        builder.AppendLine($"using {projectName}.Generated.Webhooks.Handlers;");
        builder.AppendLine($"using {projectName}.Generated.Webhooks.Parameters;");
        builder.AppendLine($"using {projectName}.Generated.Webhooks.Results;");
        return builder.ToString();
    }

    private static string GenerateMethodContent(
        OpenApiDocument openApiDoc,
        bool includeDeprecated,
        string webhookBasePath)
    {
        var builder = new StringBuilder();

        // Create a webhooks route group
        builder.AppendLine($"var webhooksGroup = endpoints.MapGroup(\"{webhookBasePath}\")");
        builder.AppendLine(4, ".WithTags(\"Webhooks\");");
        builder.AppendLine();

        var isFirst = true;

        foreach (var (webhookName, httpMethod, operation) in openApiDoc.GetAllWebhookOperations())
        {
            // Skip deprecated webhooks if not including them
            if (!includeDeprecated && operation.Deprecated)
            {
                continue;
            }

            GenerateWebhookEndpoint(builder, webhookName, httpMethod, operation, isFirst);
            isFirst = false;
        }

        builder.AppendLine();
        builder.Append("return endpoints;");

        return builder.ToString();
    }

    private static void GenerateWebhookEndpoint(
        StringBuilder builder,
        string webhookName,
        string httpMethod,
        OpenApiOperation operation,
        bool isFirst)
    {
        // Get operation ID or generate from webhook name
        var operationId = operation.OperationId ?? $"On{webhookName.EnsureFirstCharacterToUpper()}";
        var handlerName = operationId.EnsureFirstCharacterToUpper();
        var handlerInterfaceName = $"I{handlerName}WebhookHandler";

        // Convert HTTP method to Map method (webhooks typically use POST)
        var mapMethod = httpMethod.ToUpperInvariant() switch
        {
            "GET" => "MapGet",
            "POST" => "MapPost",
            "PUT" => "MapPut",
            "DELETE" => "MapDelete",
            "PATCH" => "MapPatch",
            _ => "MapPost", // Default to POST for webhooks
        };

        // Determine if webhook has parameters (request body)
        var hasParameters = operation.RequestBody != null;
        var parameterTypeName = hasParameters ? $"{handlerName}WebhookParameters" : null;

        // Add blank line before each endpoint except the first one
        if (!isFirst)
        {
            builder.AppendLine();
        }

        // Build the route path (use lowercase with hyphens for webhook name)
        var routePath = $"/{ConvertToKebabCase(webhookName)}";

        // Generate parameters for the lambda
        var parameters = new List<string>();

        if (hasParameters)
        {
            parameters.Add($"[AsParameters] {parameterTypeName} parameters");
        }

        parameters.Add($"{handlerInterfaceName} handler");
        parameters.Add("CancellationToken cancellationToken");

        // Build handler call parameters
        var handlerParams = new List<string>();
        if (hasParameters)
        {
            handlerParams.Add("parameters");
        }

        handlerParams.Add("cancellationToken");

        // Start endpoint mapping
        builder.AppendLine("webhooksGroup");
        builder.AppendLine(4, $".{mapMethod}(");
        builder.AppendLine(8, $"\"{routePath}\",");
        builder.AppendLine(8, "async (");

        // Output each parameter on its own line
        for (var i = 0; i < parameters.Count; i++)
        {
            var separator = i < parameters.Count - 1 ? "," : string.Empty;
            builder.AppendLine(12, $"{parameters[i]}{separator}");
        }

        builder.AppendLine(8, ") =>");
        builder.AppendLine(8, "{");

        // Build the handler call
        builder.AppendLine(12, "return await handler.ExecuteAsync(");
        for (var i = 0; i < handlerParams.Count; i++)
        {
            var separator = i < handlerParams.Count - 1 ? "," : ");";
            builder.AppendLine(16, $"{handlerParams[i]}{separator}");
        }

        builder.AppendLine(8, "})");

        // Add operation metadata
        if (!string.IsNullOrEmpty(operation.Summary))
        {
            var escapedSummary = operation.Summary!.Replace("\"", "\\\"");
            builder.AppendLine(4, $".WithSummary(\"{escapedSummary}\")");
        }

        builder.AppendLine(4, $".WithName(\"{operationId}\")");

        // Add Produces metadata based on responses
        GenerateProducesMetadata(builder, operation);

        // Add final semicolon
        builder.AppendLine(";");
    }

    private static void GenerateProducesMetadata(
        StringBuilder builder,
        OpenApiOperation operation)
    {
        if (operation.Responses == null || operation.Responses.Count == 0)
        {
            // Default to 200 OK for webhooks
            builder.Append(4, ".Produces(StatusCodes.Status200OK)");
            return;
        }

        var producesLines = new List<string>();

        foreach (var response in operation.Responses)
        {
            var statusCode = response.Key;

            // Handle "default" response
            if (statusCode.Equals("default", StringComparison.OrdinalIgnoreCase))
            {
                producesLines.Add("    .ProducesValidationProblem()");
                continue;
            }

            // Parse status code
            if (!int.TryParse(statusCode, out var code))
            {
                continue;
            }

            var statusConstant = code switch
            {
                200 => "Status200OK",
                201 => "Status201Created",
                202 => "Status202Accepted",
                204 => "Status204NoContent",
                400 => "Status400BadRequest",
                401 => "Status401Unauthorized",
                403 => "Status403Forbidden",
                404 => "Status404NotFound",
                500 => "Status500InternalServerError",
                _ => $"Status{code}",
            };

            // 4xx and 5xx use ProducesProblem
            if (code >= 400)
            {
                producesLines.Add($"    .ProducesProblem(StatusCodes.{statusConstant})");
            }
            else
            {
                producesLines.Add($"    .Produces(StatusCodes.{statusConstant})");
            }
        }

        // Output all lines
        for (var i = 0; i < producesLines.Count; i++)
        {
            if (i < producesLines.Count - 1)
            {
                builder.AppendLine(producesLines[i]);
            }
            else
            {
                builder.Append(producesLines[i]);
            }
        }
    }

    /// <summary>
    /// Converts a string to kebab-case (e.g., "newPet" -> "new-pet").
    /// </summary>
    private static string ConvertToKebabCase(string input)
    {
        if (string.IsNullOrEmpty(input))
        {
            return input;
        }

        var result = new StringBuilder();
        for (var i = 0; i < input.Length; i++)
        {
            var c = input[i];
            if (char.IsUpper(c))
            {
                if (i > 0)
                {
                    result.Append('-');
                }

                result.Append(char.ToLowerInvariant(c));
            }
            else
            {
                result.Append(c);
            }
        }

        return result.ToString();
    }
}