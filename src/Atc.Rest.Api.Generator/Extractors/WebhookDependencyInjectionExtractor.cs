// ReSharper disable InvertIf
namespace Atc.Rest.Api.Generator.Extractors;

/// <summary>
/// Extracts OpenAPI webhooks and generates dependency injection registration code
/// for webhook handler interfaces.
/// </summary>
public static class WebhookDependencyInjectionExtractor
{
    /// <summary>
    /// Extracts webhook dependency injection class parameters from OpenAPI document.
    /// </summary>
    /// <param name="openApiDoc">The OpenAPI document containing webhook definitions.</param>
    /// <param name="projectName">The name of the project (used for namespace).</param>
    /// <param name="includeDeprecated">Whether to include deprecated webhooks.</param>
    /// <returns>ClassParameters for the webhook DI registration class, or null if no webhooks exist.</returns>
    public static ClassParameters? Extract(
        OpenApiDocument openApiDoc,
        string projectName,
        bool includeDeprecated = false)
    {
        if (openApiDoc == null)
        {
            throw new ArgumentNullException(nameof(openApiDoc));
        }

        if (!openApiDoc.HasWebhooks())
        {
            return null;
        }

        // Collect all webhook handler interfaces
        var handlerInterfaces = new HashSet<string>(StringComparer.Ordinal);

        foreach (var (webhookName, httpMethod, operation) in openApiDoc.GetAllWebhookOperations())
        {
            // Skip deprecated webhooks if not including them
            if (!includeDeprecated && operation.Deprecated)
            {
                continue;
            }

            var operationId = operation.OperationId ?? $"On{webhookName.EnsureFirstCharacterToUpper()}";
            var handlerName = $"I{operationId.EnsureFirstCharacterToUpper()}WebhookHandler";
            handlerInterfaces.Add(handlerName);
        }

        if (handlerInterfaces.Count == 0)
        {
            return null;
        }

        // Generate method content
        var methodContent = GenerateMethodContent(handlerInterfaces);

        // Build method parameters
        var (methodParams, methodDocParams) = MethodParameterBuilder.BuildServiceCollectionExtensionParameters();

        var extensionMethod = new MethodParameters(
            DocumentationTags: new CodeDocumentationTags(
                summary: "Registers webhook handler services in the dependency injection container.",
                parameters: methodDocParams,
                remark: "Handler implementations must be registered in the Domain project.",
                code: null,
                example: null,
                exceptions: null,
                @return: "The service collection for method chaining."),
            Attributes: null,
            DeclarationModifier: DeclarationModifiers.PublicStatic,
            ReturnGenericTypeName: null,
            ReturnTypeName: "IServiceCollection",
            Name: $"Add{CasingHelper.GetLastNameSegment(projectName)}WebhookHandlers",
            Parameters: methodParams,
            AlwaysBreakDownParameters: false,
            UseExpressionBody: false,
            Content: methodContent);

        var headerContent = GenerateHeaderContent(projectName);

        return new ClassParameters(
            HeaderContent: headerContent,
            Namespace: $"{projectName}.Generated.DependencyInjection",
            DocumentationTags: new CodeDocumentationTags("Extension methods for registering webhook handlers."),
            Attributes: new List<AttributeParameters>
            {
                new("GeneratedCode", $"\"{GeneratorInfo.Name}\", \"{GeneratorInfo.Version}\""),
            },
            DeclarationModifier: DeclarationModifiers.PublicStaticClass,
            ClassTypeName: "WebhookServiceCollectionExtensions",
            GenericTypeName: null,
            InheritedClassTypeName: null,
            InheritedGenericClassTypeName: null,
            InheritedInterfaceTypeName: null,
            Constructors: null,
            Properties: null,
            Methods: new List<MethodParameters> { extensionMethod },
            GenerateToStringMethod: false);
    }

    private static string GenerateHeaderContent(string projectName)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine();
        builder.AppendLine("using System.CodeDom.Compiler;");
        builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        builder.AppendLine($"using {projectName}.Generated.Webhooks.Handlers;");
        return builder.ToString();
    }

    private static string GenerateMethodContent(
        HashSet<string> handlerInterfaces)
    {
        var builder = new StringBuilder();

        foreach (var handlerInterface in handlerInterfaces.OrderBy(h => h, StringComparer.Ordinal))
        {
            builder.AppendLine($"// Webhook handler for {handlerInterface} must be registered in the Domain project");
            builder.AppendLine($"// services.AddScoped<{handlerInterface}, YourImplementation>();");
        }

        builder.AppendLine();
        builder.Append("return services;");

        return builder.ToString();
    }
}