namespace Atc.Rest.Api.SourceGenerator;

/// <summary>
/// Source generator that auto-generates endpoint fields and constructors for partial classes
/// decorated with the [EndpointRegistration] attribute.
/// </summary>
[SuppressMessage("Design", "CA1031:Do not catch general exception types", Justification = "OK.")]
[Generator(LanguageNames.CSharp)]
public class ApiEndpointInjectionGenerator : IIncrementalGenerator
{
    private const string AttributeName = "EndpointRegistrationAttribute";
    private const string AttributeShortName = "EndpointRegistration";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Always generate the attribute as post-initialization (required for semantic analysis)
        //    The attribute has no XML doc comments to avoid duplicate documentation ID issues
        //    when multiple assemblies reference the same generated attribute.
        context.RegisterPostInitializationOutput(GenerateAttribute);

        // 2. Create syntax provider to find partial classes with [EndpointRegistration] attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node.IsPartialClassWithAttribute(),
                transform: GetClassInfo)
            .Where(info => info is not null);

        // 3. Collect YAML files for OpenAPI specs
        var yamlFiles = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith(".yaml", StringComparison.OrdinalIgnoreCase) ||
                                 file.Path.EndsWith(".yml", StringComparison.OrdinalIgnoreCase))
            .Select(static (file, cancellationToken) =>
                (Path: file.Path, Content: file.GetText(cancellationToken)?.ToString() ?? string.Empty))
            .Where(static file => !string.IsNullOrEmpty(file.Content))
            .Collect();

        // 4. Combine class declarations with YAML files
        var combined = classDeclarations.Combine(yamlFiles);

        // 5. Register source output for generating partial class code
        context.RegisterSourceOutput(combined, GeneratePartialClass!);
    }

    /// <summary>
    /// Generates the EndpointRegistrationAttribute as a post-initialization output.
    /// This attribute is always available to consuming projects.
    /// Note: No XML doc comments are included to avoid duplicate documentation ID issues
    /// when multiple assemblies (Contracts, Domain, Host) all generate this attribute.
    /// </summary>
    private static void GenerateAttribute(
        IncrementalGeneratorPostInitializationContext context)
    {
        // No XML doc comments on the attribute to prevent duplicate documentation ID errors
        // (T:Atc.Rest.Api.SourceGenerator.EndpointRegistrationAttribute) when multiple assemblies
        // reference this generated attribute and Microsoft.AspNetCore.OpenApi scans for XML docs.
        const string attributeSource = """
            // <auto-generated />
            #nullable enable
            #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

            using System;

            namespace Atc.Rest.Api.SourceGenerator
            {
                [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                internal sealed class EndpointRegistrationAttribute : Attribute
                {
                    public EndpointRegistrationAttribute(string projectName)
                    {
                        ProjectName = projectName;
                    }

                    public string ProjectName { get; }
                }
            }
            """;

        context.AddSource("EndpointRegistrationAttribute.g.cs", SourceText.From(attributeSource, Encoding.UTF8));
    }

    /// <summary>
    /// Transform to extract class information from the semantic model.
    /// </summary>
    private static ClassInfo? GetClassInfo(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get the symbol for this class
        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl, cancellationToken);
        if (classSymbol is null)
        {
            return null;
        }

        // Look for the EndpointRegistration attribute
        foreach (var attributeData in classSymbol.GetAttributes())
        {
            var attributeClass = attributeData.AttributeClass;
            if (attributeClass is null)
            {
                continue;
            }

            // Check if this is our attribute (by name)
            var attributeClassName = attributeClass.Name;
            if (!attributeClassName.Equals(AttributeName, StringComparison.Ordinal) &&
                !attributeClassName.Equals(AttributeShortName, StringComparison.Ordinal))
            {
                continue;
            }

            // Extract the project name from constructor argument
            if (attributeData.ConstructorArguments.Length == 0)
            {
                continue;
            }

            var projectNameArg = attributeData.ConstructorArguments[0];
            if (projectNameArg.Value is not string projectName || string.IsNullOrEmpty(projectName))
            {
                continue;
            }

            // Extract class information
            var className = classSymbol.Name;
            var classNamespace = classSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty;

            // Determine modifiers
            var modifiers = classDecl.GetModifiersString();

            return new ClassInfo(
                ClassName: className,
                ClassNamespace: classNamespace,
                ProjectName: projectName,
                Modifiers: modifiers);
        }

        return null;
    }

    /// <summary>
    /// Generates the partial class code with endpoint fields and constructor.
    /// </summary>
    private static void GeneratePartialClass(
        SourceProductionContext context,
        (ClassInfo ClassInfo, ImmutableArray<(string Path, string Content)> YamlFiles) input)
    {
        var (classInfo, yamlFiles) = input;

        try
        {
            // Find YAML file matching the project name
            var matchingYaml = yamlFiles.FirstOrDefault(y =>
                Path.GetFileNameWithoutExtension(y.Path).Equals(classInfo.ProjectName, StringComparison.OrdinalIgnoreCase));

            if (string.IsNullOrEmpty(matchingYaml.Content))
            {
                DiagnosticHelpers.ReportNoEndpointsFoundForInjection(context, classInfo.ProjectName);
                return;
            }

            // Parse the OpenAPI spec
            var (openApiDoc, _) = OpenApiDocumentHelper.TryParseYamlWithDiagnostic(matchingYaml.Content, matchingYaml.Path);

            if (openApiDoc == null)
            {
                DiagnosticHelpers.ReportNoEndpointsFoundForInjection(context, classInfo.ProjectName);
                return;
            }

            // Discover endpoints from OpenAPI spec
            var endpoints = EndpointInjectionExtractor.DiscoverEndpointsFromOpenApi(
                openApiDoc,
                classInfo.ProjectName);

            // Report warning if no endpoints found
            if (endpoints.Count == 0)
            {
                DiagnosticHelpers.ReportNoEndpointsFoundForInjection(context, classInfo.ProjectName);
                return;
            }

            // Generate the partial class code
            var generatedCode = EndpointInjectionExtractor.GeneratePartialClass(
                classInfo.ClassNamespace,
                classInfo.ClassName,
                endpoints,
                classInfo.Modifiers);

            // Add the generated source
            var fileName = $"{classInfo.ClassName}.EndpointInjection.g.cs";
            context.AddSource(fileName, SourceText.From(generatedCode, Encoding.UTF8));
        }
        catch (Exception ex)
        {
            DiagnosticHelpers.ReportEndpointInjectionGenerationError(context, classInfo.ClassName, ex);
        }
    }

    /// <summary>
    /// Internal record to hold class information extracted from syntax.
    /// </summary>
    private sealed record ClassInfo(
        string ClassName,
        string ClassNamespace,
        string ProjectName,
        string Modifiers);
}