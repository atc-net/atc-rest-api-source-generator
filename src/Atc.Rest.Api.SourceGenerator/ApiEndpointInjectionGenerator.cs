namespace Atc.Rest.Api.SourceGenerator;

/// <summary>
/// Source generator that auto-generates endpoint fields and constructors for partial classes
/// decorated with the [EndpointRegistration] attribute.
/// </summary>
[SuppressMessage("Design", "CA1031:Do not catch general exception types", Justification = "OK.")]
[Generator(LanguageNames.CSharp)]
public class ApiEndpointInjectionGenerator : IIncrementalGenerator
{
    private const string AttributeName = "EndpointRegistrationAttribute";
    private const string AttributeShortName = "EndpointRegistration";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Check for marker files to determine if this is a Contracts/Domain project
        //    We only want to generate the attribute in the host project (no markers)
        var hasMarkerFile = context.AdditionalTextsProvider
            .Where(static file =>
                file.Path.EndsWith(".atc-rest-api-server", StringComparison.OrdinalIgnoreCase) ||
                file.Path.EndsWith(".atc-rest-api-server-handlers", StringComparison.OrdinalIgnoreCase) ||
                file.Path.EndsWith(".atc-rest-api-client", StringComparison.OrdinalIgnoreCase))
            .Collect()
            .Select(static (markers, _) => markers.Length > 0);

        // 2. Generate the attribute only if no marker files are present (host project only)
        context.RegisterSourceOutput(hasMarkerFile, GenerateAttributeConditionally);

        // 3. Create syntax provider to find partial classes with [EndpointRegistration] attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node.IsPartialClassWithAttribute(),
                transform: GetClassInfo)
            .Where(info => info is not null);

        // 4. Collect YAML files for OpenAPI specs
        var yamlFiles = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith(".yaml", StringComparison.OrdinalIgnoreCase) ||
                                 file.Path.EndsWith(".yml", StringComparison.OrdinalIgnoreCase))
            .Select(static (file, cancellationToken) =>
                (Path: file.Path, Content: file.GetText(cancellationToken)?.ToString() ?? string.Empty))
            .Where(static file => !string.IsNullOrEmpty(file.Content))
            .Collect();

        // 5. Combine class declarations with YAML files
        var combined = classDeclarations.Combine(yamlFiles);

        // 6. Register source output for generating partial class code
        context.RegisterSourceOutput(combined, GeneratePartialClass!);
    }

    /// <summary>
    /// Generates the EndpointRegistrationAttribute only if no marker files are present.
    /// This prevents duplicate type definitions across Contracts/Domain/Host projects.
    /// </summary>
    private static void GenerateAttributeConditionally(
        SourceProductionContext context,
        bool hasMarkerFile)
    {
        // Only generate the attribute in the host project (no marker files)
        if (hasMarkerFile)
        {
            return;
        }

        const string attributeSource = """
            // <auto-generated />
            #nullable enable

            using System;

            namespace Atc.Rest.Api.SourceGenerator
            {
                /// <summary>
                /// Marks a partial class for automatic endpoint field and constructor generation.
                /// The generator will discover all endpoint interfaces matching the specified project name
                /// and generate the necessary fields and constructor.
                /// </summary>
                [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                internal sealed class EndpointRegistrationAttribute : Attribute
                {
                    /// <summary>
                    /// Initializes a new instance of the <see cref="EndpointRegistrationAttribute"/> class.
                    /// </summary>
                    /// <param name="projectName">The project name used to find endpoint interfaces (e.g., "Showcase").</param>
                    public EndpointRegistrationAttribute(string projectName)
                    {
                        ProjectName = projectName;
                    }

                    /// <summary>
                    /// Gets the project name used to find endpoint interfaces.
                    /// Endpoints in namespace '{ProjectName}.Generated.*.Endpoints.Interfaces' will be discovered.
                    /// </summary>
                    public string ProjectName { get; }
                }
            }
            """;

        context.AddSource("EndpointRegistrationAttribute.g.cs", SourceText.From(attributeSource, Encoding.UTF8));
    }

    /// <summary>
    /// Transform to extract class information from the semantic model.
    /// </summary>
    private static ClassInfo? GetClassInfo(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get the symbol for this class
        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl, cancellationToken);
        if (classSymbol is null)
        {
            return null;
        }

        // Look for the EndpointRegistration attribute
        foreach (var attributeData in classSymbol.GetAttributes())
        {
            var attributeClass = attributeData.AttributeClass;
            if (attributeClass is null)
            {
                continue;
            }

            // Check if this is our attribute (by name)
            var attributeClassName = attributeClass.Name;
            if (!attributeClassName.Equals(AttributeName, StringComparison.Ordinal) &&
                !attributeClassName.Equals(AttributeShortName, StringComparison.Ordinal))
            {
                continue;
            }

            // Extract the project name from constructor argument
            if (attributeData.ConstructorArguments.Length == 0)
            {
                continue;
            }

            var projectNameArg = attributeData.ConstructorArguments[0];
            if (projectNameArg.Value is not string projectName || string.IsNullOrEmpty(projectName))
            {
                continue;
            }

            // Extract class information
            var className = classSymbol.Name;
            var classNamespace = classSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty;

            // Determine modifiers
            var modifiers = classDecl.GetModifiersString();

            return new ClassInfo(
                ClassName: className,
                ClassNamespace: classNamespace,
                ProjectName: projectName,
                Modifiers: modifiers);
        }

        return null;
    }

    /// <summary>
    /// Generates the partial class code with endpoint fields and constructor.
    /// </summary>
    private static void GeneratePartialClass(
        SourceProductionContext context,
        (ClassInfo ClassInfo, ImmutableArray<(string Path, string Content)> YamlFiles) input)
    {
        var (classInfo, yamlFiles) = input;

        try
        {
            // Find YAML file matching the project name
            var matchingYaml = yamlFiles.FirstOrDefault(y =>
                Path.GetFileNameWithoutExtension(y.Path).Equals(classInfo.ProjectName, StringComparison.OrdinalIgnoreCase));

            if (string.IsNullOrEmpty(matchingYaml.Content))
            {
                DiagnosticHelpers.ReportNoEndpointsFoundForInjection(context, classInfo.ProjectName);
                return;
            }

            // Parse the OpenAPI spec
            var (openApiDoc, _) = OpenApiDocumentHelper.TryParseYamlWithDiagnostic(matchingYaml.Content, matchingYaml.Path);

            if (openApiDoc == null)
            {
                DiagnosticHelpers.ReportNoEndpointsFoundForInjection(context, classInfo.ProjectName);
                return;
            }

            // Discover endpoints from OpenAPI spec
            var endpoints = EndpointInjectionExtractor.DiscoverEndpointsFromOpenApi(
                openApiDoc,
                classInfo.ProjectName);

            // Report warning if no endpoints found
            if (endpoints.Count == 0)
            {
                DiagnosticHelpers.ReportNoEndpointsFoundForInjection(context, classInfo.ProjectName);
                return;
            }

            // Generate the partial class code
            var generatedCode = EndpointInjectionExtractor.GeneratePartialClass(
                classInfo.ClassNamespace,
                classInfo.ClassName,
                endpoints,
                classInfo.Modifiers);

            // Add the generated source
            var fileName = $"{classInfo.ClassName}.EndpointInjection.g.cs";
            context.AddSource(fileName, SourceText.From(generatedCode, Encoding.UTF8));
        }
        catch (Exception ex)
        {
            DiagnosticHelpers.ReportEndpointInjectionGenerationError(context, classInfo.ClassName, ex);
        }
    }

    /// <summary>
    /// Internal record to hold class information extracted from syntax.
    /// </summary>
    private sealed record ClassInfo(
        string ClassName,
        string ClassNamespace,
        string ProjectName,
        string Modifiers);
}