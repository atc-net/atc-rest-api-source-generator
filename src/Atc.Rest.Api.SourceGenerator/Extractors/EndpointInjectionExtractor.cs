namespace Atc.Rest.Api.SourceGenerator.Extractors;

/// <summary>
/// Extracts endpoint interfaces from a compilation and generates partial class code
/// for automatic dependency injection of endpoint fields and constructor.
/// </summary>
internal static class EndpointInjectionExtractor
{
    /// <summary>
    /// Discovers all endpoint interfaces by extracting operations from the OpenAPI document.
    /// This is used when the endpoint interfaces are being generated in the same compilation
    /// (source generators can't see each other's output).
    /// </summary>
    /// <param name="openApiDoc">The parsed OpenAPI document.</param>
    /// <param name="projectName">The project name (e.g., "Showcase").</param>
    /// <returns>A list of EndpointInfo records for discovered endpoints, grouped by path segment.</returns>
    public static List<EndpointInfo> DiscoverEndpointsFromOpenApi(
        OpenApiDocument openApiDoc,
        string projectName)
    {
        var endpoints = new List<EndpointInfo>();

        if (openApiDoc.Paths.Count == 0)
        {
            return endpoints;
        }

        foreach (var path in openApiDoc.Paths)
        {
            var pathKey = path.Key;
            var pathItemInterface = path.Value;

            // Extract path segment from URL (first segment after /)
            var pathSegment = PathSegmentHelper.GetFirstPathSegment(pathKey);
            if (string.IsNullOrEmpty(pathSegment))
            {
                continue;
            }

            if (pathItemInterface is not OpenApiPathItem pathItem)
            {
                continue;
            }

            if (pathItem.Operations == null)
            {
                continue;
            }

            foreach (var operation in pathItem.Operations)
            {
                var httpMethod = operation.Key.ToString();
                var operationValue = operation.Value;

                if (operationValue == null)
                {
                    continue;
                }

                // Get operation ID (or generate one from path/method)
                var operationId = operationValue.OperationId ??
                    $"{httpMethod}{pathKey.Replace("/", "_").Replace("{", string.Empty).Replace("}", string.Empty)}";

                // Convert operationId to PascalCase for interface name
                var operationName = operationId.ToPascalCaseForDotNet();

                // Generate interface name: I{OperationName}Endpoint
                var interfaceName = $"I{operationName}Endpoint";

                // Generate field name: {operationName}Endpoint in camelCase
                var fieldName = ToCamelCase($"{operationName}Endpoint");

                // Generate namespace: {projectName}.Generated.{PathSegment}.Endpoints.Interfaces
                var fullNamespace = $"{projectName}.Generated.{pathSegment}.Endpoints.Interfaces";

                endpoints.Add(new EndpointInfo(
                    InterfaceName: interfaceName,
                    PathSegment: pathSegment,
                    FieldName: fieldName,
                    FullNamespace: fullNamespace));
            }
        }

        // Sort by path segment, then by interface name for consistent output
        return endpoints
            .OrderBy(e => e.PathSegment, StringComparer.Ordinal)
            .ThenBy(e => e.InterfaceName, StringComparer.Ordinal)
            .ToList();
    }

    /// <summary>
    /// Generates a partial class with endpoint fields and constructor.
    /// </summary>
    /// <param name="classNamespace">The namespace of the partial class.</param>
    /// <param name="className">The name of the partial class.</param>
    /// <param name="endpoints">The list of discovered endpoints.</param>
    /// <param name="classModifiers">The modifiers for the class (e.g., "public sealed partial").</param>
    /// <returns>The generated partial class code.</returns>
    public static string GeneratePartialClass(
        string classNamespace,
        string className,
        List<EndpointInfo> endpoints,
        string classModifiers = "public sealed partial")
    {
        var builder = new StringBuilder();

        // Generate header
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        // Generate using statements (one per unique namespace)
        var uniqueNamespaces = endpoints
            .Select(e => e.FullNamespace)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(ns => ns, StringComparer.Ordinal);

        foreach (var ns in uniqueNamespaces)
        {
            builder.AppendLine($"using {ns};");
        }

        builder.AppendLine();

        // Generate namespace and class declaration
        builder.AppendLine($"namespace {classNamespace};");
        builder.AppendLine();
        builder.AppendLine($"{classModifiers} class {className}");
        builder.AppendLine("{");

        // Group endpoints by path segment for organized output
        var groupedEndpoints = endpoints
            .GroupBy(e => e.PathSegment, StringComparer.Ordinal)
            .ToList();

        // Generate private readonly fields
        foreach (var group in groupedEndpoints)
        {
            builder.AppendLine(4, $"// {group.Key} endpoints");
            foreach (var endpoint in group)
            {
                builder.AppendLine(4, $"private readonly {endpoint.InterfaceName} {endpoint.FieldName};");
            }

            builder.AppendLine();
        }

        // Generate constructor
        builder.AppendLine(4, $"public {className}(");

        // Constructor parameters - grouped by path segment with comments
        var parameterIndex = 0;
        var totalCount = endpoints.Count;

        foreach (var group in groupedEndpoints)
        {
            builder.AppendLine(8, $"// {group.Key}");
            foreach (var endpoint in group)
            {
                var comma = parameterIndex < totalCount - 1 ? "," : ")";
                builder.AppendLine(8, $"{endpoint.InterfaceName} {endpoint.FieldName}{comma}");
                parameterIndex++;
            }
        }

        builder.AppendLine(4, "{");

        // Constructor assignments - grouped by path segment with comments
        foreach (var group in groupedEndpoints)
        {
            builder.AppendLine(8, $"// {group.Key}");
            foreach (var endpoint in group)
            {
                builder.AppendLine(8, $"this.{endpoint.FieldName} = {endpoint.FieldName};");
            }

            builder.AppendLine();
        }

        // Remove trailing newline before closing brace
        var content = builder.ToString();
        if (content.EndsWith("\r\n\r\n", StringComparison.Ordinal))
        {
            content = content.Substring(0, content.Length - 2);
        }
        else if (content.EndsWith("\n\n", StringComparison.Ordinal))
        {
            content = content.Substring(0, content.Length - 1);
        }

        return content + new string(' ', 4) + "}\n}\n";
    }

    /// <summary>
    /// Converts a PascalCase string to camelCase.
    /// </summary>
    /// <param name="value">The PascalCase string.</param>
    /// <returns>The camelCase string.</returns>
    private static string ToCamelCase(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return value;
        }

        if (value.Length == 1)
        {
            return value.ToLowerInvariant();
        }

        return char.ToLowerInvariant(value[0]) + value.Substring(1);
    }
}