namespace Atc.Rest.Api.Generator.Cli.Extractors.TypeScript;

/// <summary>
/// Extracts OpenAPI schema definitions and converts them to Zod validation schema content.
/// </summary>
public static class TypeScriptZodModelExtractor
{
    /// <summary>
    /// Extracts all object model definitions from OpenAPI document components and generates Zod schemas.
    /// </summary>
    /// <param name="openApiDoc">The OpenAPI document containing schema definitions.</param>
    /// <param name="config">TypeScript client generation configuration.</param>
    /// <param name="enumNames">Names of types that are enums (for correct import paths).</param>
    /// <returns>List of (TypeName, GeneratedContent) tuples for each model Zod schema.</returns>
    public static List<(string Name, string Content)> Extract(
        OpenApiDocument openApiDoc,
        TypeScriptClientConfig config,
        HashSet<string>? enumNames = null)
    {
        ArgumentNullException.ThrowIfNull(openApiDoc);
        ArgumentNullException.ThrowIfNull(config);

        var results = new List<(string Name, string Content)>();

        if (openApiDoc.Components?.Schemas == null || openApiDoc.Components.Schemas.Count == 0)
        {
            return results;
        }

        var headerContent = config.GenerateFileHeaders ? TypeScriptHeaderBuilder.AutoGeneratedHeader : null;

        foreach (var schema in openApiDoc.Components.Schemas)
        {
            var schemaName = schema.Key;
            var schemaValue = schema.Value;

            // Skip schema references
            if (schemaValue is OpenApiSchemaReference)
            {
                continue;
            }

            // Skip deprecated schemas if not including them
            if (!config.IncludeDeprecated && schemaValue is OpenApiSchema { Deprecated: true })
            {
                continue;
            }

            if (schemaValue is not OpenApiSchema actualSchema)
            {
                continue;
            }

            // Skip array schemas - handled by ExtractArrayTypeAliases
            if (actualSchema.Type == JsonSchemaType.Array)
            {
                continue;
            }

            // Skip enum schemas - handled by TypeScriptZodEnumExtractor
            if (actualSchema is { Type: JsonSchemaType.String, Enum.Count: > 0 })
            {
                continue;
            }

            // Only process object schemas
            if (actualSchema.Type != JsonSchemaType.Object)
            {
                continue;
            }

            var content = GenerateZodObject(schemaName, actualSchema, headerContent, enumNames, config.NamingStrategy);
            if (content != null)
            {
                results.Add((schemaName, content));
            }
        }

        return results;
    }

    /// <summary>
    /// Extracts array wrapper schemas and generates Zod array schemas.
    /// </summary>
    /// <param name="openApiDoc">The OpenAPI document containing schema definitions.</param>
    /// <param name="config">TypeScript client generation configuration.</param>
    /// <returns>List of (TypeName, GeneratedContent) tuples for each array type Zod schema.</returns>
    public static List<(string Name, string Content)> ExtractArrayTypeAliases(
        OpenApiDocument openApiDoc,
        TypeScriptClientConfig config)
    {
        ArgumentNullException.ThrowIfNull(openApiDoc);
        ArgumentNullException.ThrowIfNull(config);

        var results = new List<(string Name, string Content)>();

        if (openApiDoc.Components?.Schemas == null || openApiDoc.Components.Schemas.Count == 0)
        {
            return results;
        }

        var headerContent = config.GenerateFileHeaders ? TypeScriptHeaderBuilder.AutoGeneratedHeader : null;

        foreach (var schema in openApiDoc.Components.Schemas)
        {
            var schemaName = schema.Key;
            var schemaValue = schema.Value;

            if (schemaValue is not OpenApiSchema actualSchema)
            {
                continue;
            }

            if (actualSchema.Type != JsonSchemaType.Array)
            {
                continue;
            }

            // Skip deprecated schemas if not including them
            if (!config.IncludeDeprecated && actualSchema.Deprecated)
            {
                continue;
            }

            var content = GenerateZodArray(schemaName, actualSchema, headerContent);
            results.Add((schemaName, content));
        }

        return results;
    }

    private static string? GenerateZodObject(
        string schemaName,
        OpenApiSchema schema,
        string? headerContent,
        HashSet<string>? enumNames,
        TypeScriptNamingStrategy namingStrategy)
    {
        var properties = schema.Properties?.ToList() ?? [];
        var required = schema.Required ?? new HashSet<string>(StringComparer.Ordinal);

        var importTypes = new HashSet<string>(StringComparer.Ordinal);

        // Detect allOf $ref for extends
        string? extendsTypeName = null;
        if (schema.AllOf is { Count: > 0 })
        {
            foreach (var subSchema in schema.AllOf)
            {
                if (subSchema is OpenApiSchemaReference allOfRef)
                {
                    extendsTypeName = allOfRef.Reference.Id ?? allOfRef.Id;
                    if (extendsTypeName != null)
                    {
                        importTypes.Add(extendsTypeName);
                    }

                    break;
                }
            }
        }

        // Collect referenced types from properties
        foreach (var prop in properties)
        {
            CollectSchemaImportTypes(prop.Value, importTypes);
        }

        var sb = new StringBuilder();

        if (headerContent != null)
        {
            sb.Append(headerContent);
        }

        sb.AppendLine("import { z } from 'zod';");

        // Build import statements for referenced schemas
        var imports = BuildZodImportStatements(importTypes, schemaName, enumNames);
        if (imports.Count > 0)
        {
            sb.AppendLine();
            foreach (var import in imports)
            {
                sb.AppendLine(import);
            }
        }

        sb.AppendLine();

        if (extendsTypeName != null)
        {
            // Use BaseSchema.extend({...})
            sb.Append("export const ").Append(schemaName).Append("Schema = ").Append(extendsTypeName).AppendLine("Schema.extend({");
        }
        else
        {
            sb.Append("export const ").Append(schemaName).AppendLine("Schema = z.object({");
        }

        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var propName = prop.Key.ApplyNamingStrategy(namingStrategy);
            var isRequired = required.Contains(prop.Key, StringComparer.Ordinal);

            var zodChain = MapPropertyToZod(prop.Value, isRequired, enumNames);

            sb.Append("  ").Append(propName).Append(": ").Append(zodChain).Append(',');
            sb.AppendLine();
        }

        sb.AppendLine("});");

        return sb.ToString();
    }

    private static string GenerateZodArray(
        string schemaName,
        OpenApiSchema arraySchema,
        string? headerContent)
    {
        var sb = new StringBuilder();

        if (headerContent != null)
        {
            sb.Append(headerContent);
        }

        sb.AppendLine("import { z } from 'zod';");

        // Add import for the item type if it references another schema
        string? itemSchemaName = null;
        if (arraySchema.Items is OpenApiSchemaReference itemRef)
        {
            itemSchemaName = itemRef.Reference.Id ?? itemRef.Id;
            if (itemSchemaName != null)
            {
                sb.AppendLine();
                sb.Append("import { ").Append(itemSchemaName).Append("Schema } from './").Append(itemSchemaName).AppendLine(".zod';");
            }
        }

        sb.AppendLine();

        sb.Append("export const ").Append(schemaName).Append("Schema = z.array(");

        if (itemSchemaName != null)
        {
            sb.Append(itemSchemaName).Append("Schema");
        }
        else if (arraySchema.Items is OpenApiSchema itemSchema)
        {
            sb.Append(MapPrimitiveToZod(itemSchema));
        }
        else
        {
            sb.Append("z.unknown()");
        }

        sb.Append(')');

        // Add minItems/maxItems constraints
        if (arraySchema.MinItems > 0)
        {
            sb.Append(".min(").Append(arraySchema.MinItems.Value.ToString(CultureInfo.InvariantCulture)).Append(')');
        }

        if (arraySchema.MaxItems > 0)
        {
            sb.Append(".max(").Append(arraySchema.MaxItems.Value.ToString(CultureInfo.InvariantCulture)).Append(')');
        }

        sb.AppendLine(";");

        return sb.ToString();
    }

    /// <summary>
    /// Maps an OpenAPI property schema to a Zod chain string.
    /// </summary>
    private static string MapPropertyToZod(
        IOpenApiSchema schema,
        bool isRequired,
        HashSet<string>? enumNames)
    {
        var sb = new StringBuilder();

        // Handle schema references ($ref)
        if (schema is OpenApiSchemaReference schemaRef)
        {
            var refName = schemaRef.Reference.Id ?? schemaRef.Id ?? "unknown";
            sb.Append(refName).Append("Schema");

            if (!isRequired)
            {
                sb.Append(".optional()");
            }

            return sb.ToString();
        }

        if (schema is not OpenApiSchema actualSchema)
        {
            sb.Append("z.unknown()");
            if (!isRequired)
            {
                sb.Append(".optional()");
            }

            return sb.ToString();
        }

        var isNullable = actualSchema.IsNullable();

        // Handle allOf compositions (commonly used for nullable $ref in OpenAPI 3.0)
        if (actualSchema.AllOf is { Count: > 0 })
        {
            foreach (var subSchema in actualSchema.AllOf)
            {
                if (subSchema is OpenApiSchemaReference allOfRef)
                {
                    var refName = allOfRef.Reference.Id ?? allOfRef.Id ?? "unknown";
                    sb.Append(refName).Append("Schema");
                    break;
                }
            }

            if (sb.Length == 0)
            {
                sb.Append("z.unknown()");
            }

            AppendModifiers(sb, isNullable, isRequired, actualSchema.Default);
            return sb.ToString();
        }

        // Handle oneOf
        if (actualSchema.OneOf is { Count: > 0 })
        {
            if (actualSchema.OneOf.Count == 1 && actualSchema.OneOf[0] is OpenApiSchemaReference oneOfRef)
            {
                var refName = oneOfRef.Reference.Id ?? oneOfRef.Id ?? "unknown";
                sb.Append(refName).Append("Schema");
            }
            else
            {
                sb.Append("z.union([");
                var first = true;
                foreach (var subSchema in actualSchema.OneOf)
                {
                    if (!first)
                    {
                        sb.Append(", ");
                    }

                    first = false;

                    if (subSchema is OpenApiSchemaReference unionRef)
                    {
                        var refName = unionRef.Reference.Id ?? unionRef.Id ?? "unknown";
                        sb.Append(refName).Append("Schema");
                    }
                    else
                    {
                        sb.Append("z.unknown()");
                    }
                }

                sb.Append("])");
            }

            AppendModifiers(sb, isNullable, isRequired, actualSchema.Default);
            return sb.ToString();
        }

        // Handle additionalProperties (Record types)
        if (actualSchema.AdditionalProperties != null)
        {
            sb.Append("z.record(z.string(), ");
            var valueZod = MapPropertyToZod(actualSchema.AdditionalProperties, isRequired: true, enumNames);
            sb.Append(valueZod).Append(')');
            AppendModifiers(sb, isNullable, isRequired, actualSchema.Default);
            return sb.ToString();
        }

        // Handle array types
        if (actualSchema.Type?.HasFlag(JsonSchemaType.Array) == true)
        {
            sb.Append("z.array(");

            if (actualSchema.Items is OpenApiSchemaReference itemRef)
            {
                var refName = itemRef.Reference.Id ?? itemRef.Id ?? "unknown";
                sb.Append(refName).Append("Schema");
            }
            else if (actualSchema.Items is OpenApiSchema itemSchema)
            {
                sb.Append(MapPrimitiveToZod(itemSchema));
            }
            else
            {
                sb.Append("z.unknown()");
            }

            sb.Append(')');

            // Array constraints
            if (actualSchema.MinItems > 0)
            {
                sb.Append(".min(").Append(actualSchema.MinItems.Value.ToString(CultureInfo.InvariantCulture)).Append(')');
            }

            if (actualSchema.MaxItems > 0)
            {
                sb.Append(".max(").Append(actualSchema.MaxItems.Value.ToString(CultureInfo.InvariantCulture)).Append(')');
            }

            AppendModifiers(sb, isNullable, isRequired, actualSchema.Default);
            return sb.ToString();
        }

        // Handle primitive types
        sb.Append(MapPrimitiveToZod(actualSchema));
        AppendModifiers(sb, isNullable, isRequired, actualSchema.Default);
        return sb.ToString();
    }

    /// <summary>
    /// Maps an OpenAPI primitive schema to a Zod base chain (without nullable/optional modifiers).
    /// </summary>
    private static string MapPrimitiveToZod(OpenApiSchema schema)
    {
        var sb = new StringBuilder();
        var typeValue = schema.Type ?? JsonSchemaType.Object;

        // Strip the Null flag
        if (typeValue.HasFlag(JsonSchemaType.Null))
        {
            typeValue &= ~JsonSchemaType.Null;
        }

        if (typeValue.HasFlag(JsonSchemaType.String))
        {
            // Check for binary format
            if (string.Equals(schema.Format, "binary", StringComparison.OrdinalIgnoreCase))
            {
                sb.Append("z.instanceof(Blob)");
                return sb.ToString();
            }

            sb.Append("z.string()");

            // Format-specific refinements
            var format = schema.Format?.ToLowerInvariant();
            switch (format)
            {
                case "email":
                    sb.Append(".email()");
                    break;
                case "uri":
                    sb.Append(".url()");
                    break;
                case "uuid":
                case "guid":
                    sb.Append(".uuid()");
                    break;
                case "date":
                    sb.Append(".date()");
                    break;
                case "date-time":
                    sb.Append(".datetime()");
                    break;
            }

            // String length constraints
            if (schema.MinLength > 0)
            {
                sb.Append(".min(").Append(schema.MinLength.Value.ToString(CultureInfo.InvariantCulture)).Append(')');
            }

            if (schema.MaxLength > 0)
            {
                sb.Append(".max(").Append(schema.MaxLength.Value.ToString(CultureInfo.InvariantCulture)).Append(')');
            }

            // Pattern constraint
            if (!string.IsNullOrWhiteSpace(schema.Pattern))
            {
                sb.Append(".regex(/").Append(schema.Pattern).Append("/)");
            }

            return sb.ToString();
        }

        if (typeValue.HasFlag(JsonSchemaType.Integer))
        {
            sb.Append("z.number().int()");
            AppendNumericConstraints(sb, schema);
            return sb.ToString();
        }

        if (typeValue.HasFlag(JsonSchemaType.Number))
        {
            sb.Append("z.number()");
            AppendNumericConstraints(sb, schema);
            return sb.ToString();
        }

        if (typeValue.HasFlag(JsonSchemaType.Boolean))
        {
            sb.Append("z.boolean()");
            return sb.ToString();
        }

        sb.Append("z.unknown()");
        return sb.ToString();
    }

    private static void AppendNumericConstraints(
        StringBuilder sb,
        OpenApiSchema schema)
    {
        if (!string.IsNullOrEmpty(schema.Minimum))
        {
            sb.Append(".min(").Append(schema.Minimum).Append(')');
        }

        if (!string.IsNullOrEmpty(schema.Maximum))
        {
            sb.Append(".max(").Append(schema.Maximum).Append(')');
        }
    }

    private static void AppendModifiers(
        StringBuilder sb,
        bool isNullable,
        bool isRequired,
        JsonNode? defaultValue)
    {
        if (isNullable)
        {
            sb.Append(".nullable()");
        }

        if (!isRequired)
        {
            sb.Append(".optional()");
        }

        if (defaultValue != null)
        {
            var defaultStr = FormatDefaultValue(defaultValue);
            if (defaultStr != null)
            {
                sb.Append(".default(").Append(defaultStr).Append(')');
            }
        }
    }

    private static string? FormatDefaultValue(JsonNode defaultValue)
    {
        if (defaultValue is JsonValue jsonValue)
        {
            if (jsonValue.TryGetValue<bool>(out var boolVal))
            {
                return boolVal ? "true" : "false";
            }

            if (jsonValue.TryGetValue<long>(out var longVal))
            {
                return longVal.ToString(CultureInfo.InvariantCulture);
            }

            if (jsonValue.TryGetValue<double>(out var doubleVal))
            {
                return doubleVal.ToString(CultureInfo.InvariantCulture);
            }

            if (jsonValue.TryGetValue<string>(out var strVal))
            {
                return $"'{strVal}'";
            }
        }

        return null;
    }

    /// <summary>
    /// Collects referenced type names from a schema for generating Zod import statements.
    /// </summary>
    private static void CollectSchemaImportTypes(
        IOpenApiSchema schema,
        HashSet<string> importTypes)
    {
        if (schema is OpenApiSchemaReference schemaRef)
        {
            var refName = schemaRef.Reference.Id ?? schemaRef.Id;
            if (refName != null)
            {
                importTypes.Add(refName);
            }

            return;
        }

        if (schema is not OpenApiSchema actualSchema)
        {
            return;
        }

        // Check allOf references
        if (actualSchema.AllOf is { Count: > 0 })
        {
            foreach (var subSchema in actualSchema.AllOf)
            {
                if (subSchema is OpenApiSchemaReference allOfRef)
                {
                    var refName = allOfRef.Reference.Id ?? allOfRef.Id;
                    if (refName != null)
                    {
                        importTypes.Add(refName);
                    }
                }
            }
        }

        // Check oneOf references
        if (actualSchema.OneOf is { Count: > 0 })
        {
            foreach (var subSchema in actualSchema.OneOf)
            {
                if (subSchema is OpenApiSchemaReference oneOfRef)
                {
                    var refName = oneOfRef.Reference.Id ?? oneOfRef.Id;
                    if (refName != null)
                    {
                        importTypes.Add(refName);
                    }
                }
            }
        }

        // Check array item references
        if (actualSchema.Type?.HasFlag(JsonSchemaType.Array) == true && actualSchema.Items is OpenApiSchemaReference itemRef)
        {
            var refName = itemRef.Reference.Id ?? itemRef.Id;
            if (refName != null)
            {
                importTypes.Add(refName);
            }
        }

        // Check additionalProperties references
        if (actualSchema.AdditionalProperties is OpenApiSchemaReference addPropRef)
        {
            var refName = addPropRef.Reference.Id ?? addPropRef.Id;
            if (refName != null)
            {
                importTypes.Add(refName);
            }
        }
    }

    /// <summary>
    /// Builds import statements for referenced Zod schemas.
    /// </summary>
    private static List<string> BuildZodImportStatements(
        HashSet<string> importTypes,
        string currentTypeName,
        HashSet<string>? enumNames)
    {
        var imports = new List<string>();

        foreach (var typeName in importTypes.OrderBy(t => t, StringComparer.Ordinal))
        {
            // Don't import self
            if (typeName.Equals(currentTypeName, StringComparison.Ordinal))
            {
                continue;
            }

            // Use correct relative path based on whether the type is an enum or model
            var importPath = enumNames != null && enumNames.Contains(typeName)
                ? $"../enums/{typeName}.zod"
                : $"./{typeName}.zod";

            imports.Add($"import {{ {typeName}Schema }} from '{importPath}';");
        }

        return imports;
    }
}