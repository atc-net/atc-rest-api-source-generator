namespace Atc.Rest.Api.Generator.Cli.Extractors.TypeScript;

/// <summary>
/// Extracts OpenAPI schema definitions and converts them to TypeScript interface parameters.
/// </summary>
public static class TypeScriptModelExtractor
{
    /// <summary>
    /// Extracts all model definitions from OpenAPI document components.
    /// </summary>
    /// <param name="openApiDoc">The OpenAPI document containing schema definitions.</param>
    /// <param name="config">TypeScript client generation configuration.</param>
    /// <param name="enumNames">Names of types that are enums (for correct import paths).</param>
    /// <returns>List of (TypeName, InterfaceParameters) tuples for each model.</returns>
    public static List<(string Name, TypeScriptInterfaceParameters Parameters)> Extract(
        OpenApiDocument openApiDoc,
        TypeScriptClientConfig config,
        HashSet<string>? enumNames = null)
    {
        ArgumentNullException.ThrowIfNull(openApiDoc);
        ArgumentNullException.ThrowIfNull(config);

        var results = new List<(string Name, TypeScriptInterfaceParameters Parameters)>();

        if (openApiDoc.Components?.Schemas == null || openApiDoc.Components.Schemas.Count == 0)
        {
            return results;
        }

        var headerContent = config.GenerateFileHeaders ? TypeScriptHeaderBuilder.AutoGeneratedHeader : null;

        foreach (var schema in openApiDoc.Components.Schemas)
        {
            var originalSchemaName = schema.Key;
            var schemaValue = schema.Value;

            // Skip schema references
            if (schemaValue is OpenApiSchemaReference)
            {
                continue;
            }

            // Skip deprecated schemas if not including them
            if (!config.IncludeDeprecated && schemaValue is OpenApiSchema { Deprecated: true })
            {
                continue;
            }

            if (schemaValue is not OpenApiSchema actualSchema)
            {
                continue;
            }

            // Skip array schemas - they are handled by ExtractArrayTypeAliases
            if (actualSchema.Type == JsonSchemaType.Array)
            {
                continue;
            }

            // Skip enum schemas - handled by TypeScriptEnumExtractor
            if (actualSchema is { Type: JsonSchemaType.String, Enum.Count: > 0 })
            {
                continue;
            }

            // Only process object schemas
            if (actualSchema.Type != JsonSchemaType.Object)
            {
                continue;
            }

            var interfaceParams = ExtractInterfaceFromSchema(originalSchemaName, actualSchema, headerContent, enumNames);
            if (interfaceParams != null)
            {
                results.Add((originalSchemaName, interfaceParams));
            }
        }

        return results;
    }

    /// <summary>
    /// Extracts array wrapper schemas as TypeScript type aliases (e.g., export type Accounts = Account[];).
    /// These are named array schemas in components/schemas that wrap a $ref item type.
    /// </summary>
    /// <param name="openApiDoc">The OpenAPI document containing schema definitions.</param>
    /// <param name="config">TypeScript client generation configuration.</param>
    /// <returns>List of (TypeName, FileContent) tuples for each array type alias.</returns>
    public static List<(string Name, string Content)> ExtractArrayTypeAliases(
        OpenApiDocument openApiDoc,
        TypeScriptClientConfig config)
    {
        ArgumentNullException.ThrowIfNull(openApiDoc);
        ArgumentNullException.ThrowIfNull(config);

        var results = new List<(string Name, string Content)>();

        if (openApiDoc.Components?.Schemas == null || openApiDoc.Components.Schemas.Count == 0)
        {
            return results;
        }

        var headerContent = config.GenerateFileHeaders ? TypeScriptHeaderBuilder.AutoGeneratedHeader : null;

        foreach (var schema in openApiDoc.Components.Schemas)
        {
            var schemaName = schema.Key;
            var schemaValue = schema.Value;

            if (schemaValue is not OpenApiSchema actualSchema)
            {
                continue;
            }

            if (actualSchema.Type != JsonSchemaType.Array)
            {
                continue;
            }

            // Skip deprecated schemas if not including them
            if (!config.IncludeDeprecated && actualSchema.Deprecated)
            {
                continue;
            }

            var itemType = GetArrayItemTypeName(actualSchema);
            var sb = new StringBuilder();

            if (headerContent != null)
            {
                sb.Append(headerContent);
            }

            // Add import for the item type if it references another schema
            if (actualSchema.Items is OpenApiSchemaReference)
            {
                sb.Append("import type { ").Append(itemType).Append(" } from './").Append(itemType).AppendLine("';");
                sb.AppendLine();
            }

            sb.Append("export type ").Append(schemaName).Append(" = ").Append(itemType).AppendLine("[];");

            results.Add((schemaName, sb.ToString()));
        }

        return results;
    }

    private static string GetArrayItemTypeName(OpenApiSchema arraySchema)
    {
        if (arraySchema.Items is OpenApiSchemaReference itemRef)
        {
            return itemRef.Reference.Id ?? itemRef.Id ?? "unknown";
        }

        if (arraySchema.Items is OpenApiSchema itemSchema)
        {
            return itemSchema.Type.ToTypeScriptTypeName(itemSchema.Format);
        }

        return "unknown";
    }

    /// <summary>
    /// Extracts a single TypeScript interface from an OpenAPI schema.
    /// </summary>
    private static TypeScriptInterfaceParameters? ExtractInterfaceFromSchema(
        string schemaName,
        OpenApiSchema schema,
        string? headerContent,
        HashSet<string>? enumNames)
    {
        var properties = schema.Properties?.ToList() ?? [];
        var required = schema.Required ?? new HashSet<string>(StringComparer.Ordinal);

        var tsProperties = new List<TypeScriptPropertyParameters>();
        var importTypes = new HashSet<string>(StringComparer.Ordinal);

        // Detect allOf $ref for extends
        string? extendsTypeName = null;
        if (schema.AllOf is { Count: > 0 })
        {
            foreach (var subSchema in schema.AllOf)
            {
                if (subSchema is OpenApiSchemaReference allOfRef)
                {
                    extendsTypeName = allOfRef.Reference.Id ?? allOfRef.Id;
                    if (extendsTypeName != null)
                    {
                        importTypes.Add(extendsTypeName);
                    }

                    break;
                }
            }
        }

        foreach (var prop in properties)
        {
            var propName = prop.Key.ToCamelCase();
            var isRequired = required.Contains(prop.Key, StringComparer.Ordinal);
            var tsType = prop.Value.ToTypeScriptTypeForModel(isRequired);

            // Track referenced types for imports
            CollectReferencedTypes(prop.Value, importTypes);

            // Build description from schema if available
            JsDocComment? docTags = null;
            if (prop.Value is OpenApiSchema propSchema && !string.IsNullOrEmpty(propSchema.Description))
            {
                docTags = new JsDocComment(propSchema.Description);
            }

            tsProperties.Add(new TypeScriptPropertyParameters(
                DocumentationTags: docTags,
                IsReadonly: true,
                TypeAnnotation: tsType,
                IsOptional: !isRequired,
                Name: propName,
                DefaultValue: null));
        }

        // Build import statements
        var importStatements = BuildImportStatements(importTypes, schemaName, enumNames);

        // Build JSDoc for the interface itself
        JsDocComment? interfaceDocTags = null;
        if (!string.IsNullOrEmpty(schema.Description))
        {
            interfaceDocTags = new JsDocComment(schema.Description);
        }

        return new TypeScriptInterfaceParameters(
            HeaderContent: headerContent,
            DocumentationTags: interfaceDocTags,
            Modifiers: TypeScriptModifiers.Export,
            TypeName: schemaName,
            ExtendsTypeName: extendsTypeName,
            ImportStatements: importStatements.Count > 0 ? importStatements : null,
            Properties: tsProperties.Count > 0 ? tsProperties : null,
            Methods: null);
    }

    /// <summary>
    /// Collects referenced type names from a schema for generating import statements.
    /// </summary>
    private static void CollectReferencedTypes(
        IOpenApiSchema schema,
        HashSet<string> importTypes)
    {
        if (schema is OpenApiSchemaReference schemaRef)
        {
            var refName = schemaRef.Reference.Id ?? schemaRef.Id;
            if (refName != null)
            {
                importTypes.Add(refName);
            }

            return;
        }

        if (schema is not OpenApiSchema actualSchema)
        {
            return;
        }

        // Check allOf references
        if (actualSchema.AllOf is { Count: > 0 })
        {
            foreach (var subSchema in actualSchema.AllOf)
            {
                if (subSchema is OpenApiSchemaReference allOfRef)
                {
                    var refName = allOfRef.Reference.Id ?? allOfRef.Id;
                    if (refName != null)
                    {
                        importTypes.Add(refName);
                    }
                }
            }
        }

        // Check oneOf references
        if (actualSchema.OneOf is { Count: > 0 })
        {
            foreach (var subSchema in actualSchema.OneOf)
            {
                if (subSchema is OpenApiSchemaReference oneOfRef)
                {
                    var refName = oneOfRef.Reference.Id ?? oneOfRef.Id;
                    if (refName != null)
                    {
                        importTypes.Add(refName);
                    }
                }
            }
        }

        // Check array item references
        if (actualSchema.Type?.HasFlag(JsonSchemaType.Array) == true && actualSchema.Items is OpenApiSchemaReference itemRef)
        {
            var refName = itemRef.Reference.Id ?? itemRef.Id;
            if (refName != null)
            {
                importTypes.Add(refName);
            }
        }

        // Check additionalProperties references
        if (actualSchema.AdditionalProperties is OpenApiSchemaReference addPropRef)
        {
            var refName = addPropRef.Reference.Id ?? addPropRef.Id;
            if (refName != null)
            {
                importTypes.Add(refName);
            }
        }
    }

    /// <summary>
    /// Builds import statements for referenced types.
    /// </summary>
    private static List<string> BuildImportStatements(
        HashSet<string> importTypes,
        string currentTypeName,
        HashSet<string>? enumNames)
    {
        var imports = new List<string>();

        foreach (var typeName in importTypes.OrderBy(t => t, StringComparer.Ordinal))
        {
            // Don't import self
            if (typeName.Equals(currentTypeName, StringComparison.Ordinal))
            {
                continue;
            }

            // Use correct relative path based on whether the type is an enum or model
            var importPath = enumNames != null && enumNames.Contains(typeName)
                ? $"../enums/{typeName}"
                : $"./{typeName}";

            imports.Add($"import type {{ {typeName} }} from '{importPath}';");
        }

        return imports;
    }
}