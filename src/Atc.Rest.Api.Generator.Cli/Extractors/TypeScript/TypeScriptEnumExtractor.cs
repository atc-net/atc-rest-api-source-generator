namespace Atc.Rest.Api.Generator.Cli.Extractors.TypeScript;

/// <summary>
/// Extracts OpenAPI enum schema definitions and converts them to TypeScript enum or union type content.
/// </summary>
public static class TypeScriptEnumExtractor
{
    /// <summary>
    /// Extracts all enum definitions from OpenAPI document components.
    /// </summary>
    /// <param name="openApiDoc">The OpenAPI document containing schema definitions.</param>
    /// <param name="config">TypeScript client generation configuration.</param>
    /// <returns>List of (TypeName, GeneratedContent) tuples for each enum.</returns>
    public static List<(string Name, string Content)> Extract(
        OpenApiDocument openApiDoc,
        TypeScriptClientConfig config)
    {
        ArgumentNullException.ThrowIfNull(openApiDoc);
        ArgumentNullException.ThrowIfNull(config);

        var results = new List<(string Name, string Content)>();

        if (openApiDoc.Components?.Schemas == null || openApiDoc.Components.Schemas.Count == 0)
        {
            return results;
        }

        var headerContent = config.GenerateFileHeaders ? TypeScriptHeaderBuilder.AutoGeneratedHeader : null;

        foreach (var schema in openApiDoc.Components.Schemas)
        {
            var schemaName = schema.Key;
            var schemaValue = schema.Value;

            // Skip schema references
            if (schemaValue is OpenApiSchemaReference)
            {
                continue;
            }

            if (schemaValue is not OpenApiSchema actualSchema)
            {
                continue;
            }

            // Only process string enums
            if (actualSchema.Type != JsonSchemaType.String || actualSchema.Enum is not { Count: > 0 })
            {
                continue;
            }

            // Skip deprecated if not including them
            if (!config.IncludeDeprecated && actualSchema.Deprecated)
            {
                continue;
            }

            var enumValues = ExtractEnumValues(actualSchema.Enum);
            if (enumValues == null || enumValues.Count == 0)
            {
                continue;
            }

            // Build JSDoc from schema description
            JsDocComment? docTags = null;
            if (!string.IsNullOrEmpty(actualSchema.Description))
            {
                docTags = new JsDocComment(actualSchema.Description);
            }

            string content;
            if (config.EnumStyle == TypeScriptEnumStyle.Union)
            {
                content = GenerateUnionType(headerContent, docTags, schemaName, enumValues);
            }
            else
            {
                content = GenerateEnum(headerContent, docTags, schemaName, enumValues);
            }

            results.Add((schemaName, content));
        }

        return results;
    }

    /// <summary>
    /// Generates a string union type alias.
    /// </summary>
    private static string GenerateUnionType(
        string? headerContent,
        JsDocComment? docTags,
        string typeName,
        List<string> values)
    {
        var parameters = TypeScriptTypeAliasParametersFactory.CreateStringUnion(
            headerContent,
            docTags,
            typeName,
            values);

        var generator = new GenerateContentForTypeAlias(
            new JsDocCommentGenerator(),
            parameters);

        return generator.Generate();
    }

    /// <summary>
    /// Generates a TypeScript enum declaration.
    /// </summary>
    private static string GenerateEnum(
        string? headerContent,
        JsDocComment? docTags,
        string typeName,
        List<string> values)
    {
        var nameValuePairs = values
            .Select(v => new KeyValuePair<string, string>(v.ToPascalCase(), $"'{v}'"))
            .ToList();

        var parameters = TypeScriptEnumParametersFactory.CreateFromNameValuePairs(
            headerContent,
            docTags,
            typeName,
            nameValuePairs);

        var generator = new GenerateContentForEnum(
            new JsDocCommentGenerator(),
            parameters);

        return generator.Generate();
    }

    /// <summary>
    /// Extracts string values from OpenAPI enum nodes.
    /// </summary>
    private static List<string>? ExtractEnumValues(IList<JsonNode>? enumValues)
    {
        if (enumValues == null || enumValues.Count == 0)
        {
            return null;
        }

        var result = new List<string>();

        foreach (var enumValue in enumValues)
        {
            var valueStr = enumValue?.ToString();
            if (string.IsNullOrEmpty(valueStr))
            {
                continue;
            }

            // Clean up the value - remove quotes if present
            var cleanValue = valueStr!.Trim('"');
            result.Add(cleanValue);
        }

        return result.Count > 0 ? result : null;
    }
}