namespace Atc.Rest.Api.Generator.Cli.Services;

/// <summary>
/// Orchestrates TypeScript client generation from OpenAPI documents.
/// </summary>
public static class TypeScriptClientGenerationService
{
    /// <summary>
    /// Generates all TypeScript client files from an OpenAPI document.
    /// Includes models, enums, error types, ApiResult, base client, and per-segment clients.
    /// </summary>
    /// <param name="openApiDoc">The parsed OpenAPI document.</param>
    /// <param name="outputPath">The root output directory for generated files.</param>
    /// <param name="config">TypeScript client generation configuration.</param>
    /// <returns>A result containing counts of generated files.</returns>
    public static TypeScriptGenerationResult Generate(
        OpenApiDocument openApiDoc,
        string outputPath,
        TypeScriptClientConfig config)
    {
        ArgumentNullException.ThrowIfNull(openApiDoc);
        ArgumentNullException.ThrowIfNull(config);

        var headerContent = config.GenerateFileHeaders ? TypeScriptHeaderBuilder.AutoGeneratedHeader : null;

        // Step 1: Extract enums first (needed for correct import paths in models)
        var enums = TypeScriptEnumExtractor.Extract(openApiDoc, config);
        var enumNameSet = new HashSet<string>(enums.Select(e => e.Name), StringComparer.Ordinal);
        var enumCount = WriteEnums(enums, outputPath, headerContent);

        // Step 2: Extract and generate models (with enum names for correct import paths)
        var models = TypeScriptModelExtractor.Extract(openApiDoc, config, enumNameSet);
        var arrayTypeAliases = TypeScriptModelExtractor.ExtractArrayTypeAliases(openApiDoc, config);
        var modelCount = WriteModels(models, arrayTypeAliases, outputPath, headerContent);

        // Step 3: Generate error types
        var errorTypeCount = WriteErrorTypes(outputPath, headerContent);

        // Step 4: Generate ApiResult type
        var typeCount = WriteApiResultType(outputPath, headerContent);

        // Step 5: Generate client classes
        var clientCount = WriteClients(openApiDoc, outputPath, headerContent, enumNameSet);

        // Step 6: Generate root barrel export
        var subdirectories = new List<string>();
        if (modelCount > 0)
        {
            subdirectories.Add("models");
        }

        if (enumCount > 0)
        {
            subdirectories.Add("enums");
        }

        if (errorTypeCount > 0)
        {
            subdirectories.Add("errors");
        }

        if (typeCount > 0)
        {
            subdirectories.Add("types");
        }

        if (clientCount > 0)
        {
            subdirectories.Add("client");
        }

        if (subdirectories.Count > 0)
        {
            WriteRootBarrelExport(outputPath, headerContent, subdirectories);
        }

        return new TypeScriptGenerationResult(
            ModelCount: modelCount,
            EnumCount: enumCount,
            ErrorTypeCount: errorTypeCount,
            TypeCount: typeCount,
            ClientCount: clientCount);
    }

    /// <summary>
    /// Writes model files (interfaces and array type aliases) and their barrel export.
    /// </summary>
    private static int WriteModels(
        List<(string Name, TypeScriptInterfaceParameters Parameters)> models,
        List<(string Name, string Content)> arrayTypeAliases,
        string outputPath,
        string? headerContent)
    {
        var totalCount = models.Count + arrayTypeAliases.Count;
        if (totalCount == 0)
        {
            return 0;
        }

        var modelsDir = Path.Combine(outputPath, "models");
        var jsDocGenerator = new JsDocCommentGenerator();
        var writer = new GenerateContentWriter(jsDocGenerator);

        foreach (var (name, parameters) in models)
        {
            var generator = new GenerateContentForInterface(writer, parameters);
            var content = generator.Generate();
            var filePath = Path.Combine(modelsDir, $"{name}.ts");
            Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(filePath, content);
        }

        // Write array type alias files (e.g., export type Accounts = Account[];)
        foreach (var (name, content) in arrayTypeAliases)
        {
            var filePath = Path.Combine(modelsDir, $"{name}.ts");
            Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(filePath, content);
        }

        // Generate barrel export for all models (interfaces + type aliases)
        var allModelNames = models.Select(m => m.Name)
            .Concat(arrayTypeAliases.Select(a => a.Name));
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, allModelNames);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(modelsDir, "index.ts"), barrelContent);

        return totalCount;
    }

    /// <summary>
    /// Writes enum files and their barrel export.
    /// </summary>
    private static int WriteEnums(
        List<(string Name, string Content)> enums,
        string outputPath,
        string? headerContent)
    {
        if (enums.Count == 0)
        {
            return 0;
        }

        var enumsDir = Path.Combine(outputPath, "enums");

        foreach (var (name, content) in enums)
        {
            var filePath = Path.Combine(enumsDir, $"{name}.ts");
            Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(filePath, content);
        }

        // Generate barrel export for enums - use non-type-only for enum style Enum (they are values)
        var enumNames = enums.Select(e => e.Name);
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, enumNames, isTypeOnly: false);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(enumsDir, "index.ts"), barrelContent);

        return enums.Count;
    }

    /// <summary>
    /// Writes error type files and their barrel export.
    /// </summary>
    private static int WriteErrorTypes(
        string outputPath,
        string? headerContent)
    {
        var errorsDir = Path.Combine(outputPath, "errors");

        var apiErrorContent = TypeScriptErrorExtractor.GenerateApiError(headerContent);
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(errorsDir, "ApiError.ts"), apiErrorContent);

        var validationErrorContent = TypeScriptErrorExtractor.GenerateValidationError(headerContent);
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(errorsDir, "ValidationError.ts"), validationErrorContent);

        // Generate barrel export for errors (not type-only, they are classes)
        var errorNames = new[] { "ApiError", "ValidationError" };
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, errorNames, isTypeOnly: false);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(errorsDir, "index.ts"), barrelContent);

        return 2;
    }

    /// <summary>
    /// Writes the ApiResult type file and its barrel export.
    /// </summary>
    private static int WriteApiResultType(
        string outputPath,
        string? headerContent)
    {
        var typesDir = Path.Combine(outputPath, "types");

        var apiResultContent = TypeScriptApiResultExtractor.Generate(headerContent);
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(typesDir, "ApiResult.ts"), apiResultContent);

        // Generate barrel export for types
        var typeNames = new[] { "ApiResult" };
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, typeNames);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(typesDir, "index.ts"), barrelContent);

        return 1;
    }

    /// <summary>
    /// Writes client class files and their barrel export.
    /// </summary>
    private static int WriteClients(
        OpenApiDocument openApiDoc,
        string outputPath,
        string? headerContent,
        HashSet<string> enumNameSet)
    {
        var clients = TypeScriptClientExtractor.Extract(openApiDoc, headerContent, enumNameSet);
        if (clients.Count == 0)
        {
            return 0;
        }

        var clientDir = Path.Combine(outputPath, "client");

        // Write base ApiClient
        var apiClientContent = TypeScriptApiClientExtractor.Generate(headerContent);
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(clientDir, "ApiClient.ts"), apiClientContent);

        // Write per-segment client files
        foreach (var (className, content) in clients)
        {
            var filePath = Path.Combine(clientDir, $"{className}.ts");
            Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(filePath, content);
        }

        // Generate barrel export for client directory (not type-only, they are classes)
        var clientNames = new List<string> { "ApiClient" };
        clientNames.AddRange(clients.Select(c => c.ClassName));
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, clientNames, isTypeOnly: false);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(clientDir, "index.ts"), barrelContent);

        return clients.Count;
    }

    /// <summary>
    /// Writes the root barrel export (index.ts) that re-exports from subdirectories.
    /// </summary>
    private static void WriteRootBarrelExport(
        string outputPath,
        string? headerContent,
        List<string> subdirectories)
    {
        var barrelParams = TypeScriptBarrelExportExtractor.CreateForSubdirectories(headerContent, subdirectories);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        Atc.CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(Path.Combine(outputPath, "index.ts"), barrelContent);
    }
}