namespace Atc.Rest.Api.Generator.Cli.Services;

/// <summary>
/// Orchestrates TypeScript client generation from OpenAPI documents.
/// </summary>
public static class TypeScriptClientGenerationService
{
    /// <summary>
    /// Generates all TypeScript client files from an OpenAPI document.
    /// Includes models, enums, error types, ApiResult, base client, and per-segment clients.
    /// </summary>
    /// <param name="openApiDoc">The parsed OpenAPI document.</param>
    /// <param name="outputPath">The root output directory for generated files.</param>
    /// <param name="config">TypeScript client generation configuration.</param>
    /// <returns>A result containing counts of generated files.</returns>
    public static TypeScriptGenerationResult Generate(
        OpenApiDocument openApiDoc,
        string outputPath,
        TypeScriptClientConfig config)
    {
        ArgumentNullException.ThrowIfNull(openApiDoc);
        ArgumentNullException.ThrowIfNull(config);

        var dryRun = config.DryRun;
        var headerContent = config.GenerateFileHeaders ? TypeScriptHeaderBuilder.AutoGeneratedHeader : null;

        // Step 1: Extract enums first (needed for correct import paths in models)
        var enums = TypeScriptEnumExtractor.Extract(openApiDoc, config);
        var enumNameSet = new HashSet<string>(enums.Select(e => e.Name), StringComparer.Ordinal);
        var enumCount = WriteEnums(enums, outputPath, headerContent, config.GenerateZodSchemas, dryRun);

        // Step 2: Extract and generate models (with enum names for correct import paths)
        var models = TypeScriptModelExtractor.Extract(openApiDoc, config, enumNameSet);
        var arrayTypeAliases = TypeScriptModelExtractor.ExtractArrayTypeAliases(openApiDoc, config);
        var modelCount = WriteModels(models, arrayTypeAliases, outputPath, headerContent, config.GenerateZodSchemas, dryRun);

        // Step 3: Generate error types
        var errorTypeCount = WriteErrorTypes(outputPath, headerContent, config.HttpClient, dryRun);

        // Step 4: Generate ApiResult type
        var typeCount = WriteApiResultType(outputPath, headerContent, config.HttpClient, dryRun);

        // Step 5: Generate client classes
        var clientCount = WriteClients(openApiDoc, outputPath, headerContent, enumNameSet, config.HttpClient, config.NamingStrategy, config.ConvertDates, dryRun);

        // Step 6: Generate React Query hooks (if configured)
        var hookCount = 0;
        if (config.HooksStyle == TypeScriptHooksStyle.ReactQuery && clientCount > 0)
        {
            hookCount = WriteReactQueryHooks(openApiDoc, outputPath, headerContent, enumNameSet, config.NamingStrategy, dryRun);
        }

        // Step 6b: Generate Zod schemas (if configured)
        var zodSchemaCount = 0;
        if (config.GenerateZodSchemas)
        {
            zodSchemaCount = WriteZodSchemas(openApiDoc, outputPath, headerContent, config, enumNameSet, dryRun);
        }

        // Step 7: Generate package scaffold (if configured)
        var scaffoldGenerated = false;
        if (config.Scaffold)
        {
            scaffoldGenerated = WritePackageScaffold(openApiDoc, outputPath, config, dryRun);
        }

        // Step 8: Generate root barrel export
        var subdirectories = new List<string>();
        if (modelCount > 0)
        {
            subdirectories.Add("models");
        }

        if (enumCount > 0)
        {
            subdirectories.Add("enums");
        }

        if (errorTypeCount > 0)
        {
            subdirectories.Add("errors");
        }

        if (typeCount > 0)
        {
            subdirectories.Add("types");
        }

        if (clientCount > 0)
        {
            subdirectories.Add("client");
        }

        if (hookCount > 0)
        {
            subdirectories.Add("hooks");
        }

        if (subdirectories.Count > 0)
        {
            WriteRootBarrelExport(outputPath, headerContent, subdirectories, dryRun);
        }

        return new TypeScriptGenerationResult(
            ModelCount: modelCount,
            EnumCount: enumCount,
            ErrorTypeCount: errorTypeCount,
            TypeCount: typeCount,
            ClientCount: clientCount,
            HookCount: hookCount,
            ZodSchemaCount: zodSchemaCount,
            ScaffoldGenerated: scaffoldGenerated);
    }

    /// <summary>
    /// Writes model files (interfaces and array type aliases) and their barrel export.
    /// </summary>
    private static int WriteModels(
        List<(string Name, TypeScriptInterfaceParameters Parameters)> models,
        List<(string Name, string Content)> arrayTypeAliases,
        string outputPath,
        string? headerContent,
        bool includeZod,
        bool dryRun)
    {
        var totalCount = models.Count + arrayTypeAliases.Count;
        if (totalCount == 0)
        {
            return 0;
        }

        var modelsDir = Path.Combine(outputPath, "models");
        var jsDocGenerator = new JsDocCommentGenerator();
        var writer = new GenerateContentWriter(jsDocGenerator);

        foreach (var (name, parameters) in models)
        {
            var generator = new GenerateContentForInterface(writer, parameters);
            var content = generator.Generate();
            var filePath = Path.Combine(modelsDir, $"{name}.ts");
            WriteTsFile(filePath, content, dryRun);
        }

        // Write array type alias files (e.g., export type Accounts = Account[];)
        foreach (var (name, content) in arrayTypeAliases)
        {
            var filePath = Path.Combine(modelsDir, $"{name}.ts");
            WriteTsFile(filePath, content, dryRun);
        }

        // Generate barrel export for all models (interfaces + type aliases)
        var allModelNames = models.Select(m => m.Name)
            .Concat(arrayTypeAliases.Select(a => a.Name));

        var barrelParams = includeZod
            ? TypeScriptBarrelExportExtractor.CreateWithZod(headerContent, allModelNames)
            : TypeScriptBarrelExportExtractor.Create(headerContent, allModelNames);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        WriteTsFile(Path.Combine(modelsDir, "index.ts"), barrelContent, dryRun);

        return totalCount;
    }

    /// <summary>
    /// Writes enum files and their barrel export.
    /// </summary>
    private static int WriteEnums(
        List<(string Name, string Content)> enums,
        string outputPath,
        string? headerContent,
        bool includeZod,
        bool dryRun)
    {
        if (enums.Count == 0)
        {
            return 0;
        }

        var enumsDir = Path.Combine(outputPath, "enums");

        foreach (var (name, content) in enums)
        {
            var filePath = Path.Combine(enumsDir, $"{name}.ts");
            WriteTsFile(filePath, content, dryRun);
        }

        // Generate barrel export for enums - use non-type-only for enum style Enum (they are values)
        var enumNames = enums.Select(e => e.Name);
        var barrelParams = includeZod
            ? TypeScriptBarrelExportExtractor.CreateWithZod(headerContent, enumNames, isTypeOnly: false)
            : TypeScriptBarrelExportExtractor.Create(headerContent, enumNames, isTypeOnly: false);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        WriteTsFile(Path.Combine(enumsDir, "index.ts"), barrelContent, dryRun);

        return enums.Count;
    }

    /// <summary>
    /// Writes error type files and their barrel export.
    /// </summary>
    private static int WriteErrorTypes(
        string outputPath,
        string? headerContent,
        TypeScriptHttpClient httpClient,
        bool dryRun)
    {
        var errorsDir = Path.Combine(outputPath, "errors");

        var apiErrorContent = TypeScriptErrorExtractor.GenerateApiError(headerContent, httpClient);
        WriteTsFile(Path.Combine(errorsDir, "ApiError.ts"), apiErrorContent, dryRun);

        var validationErrorContent = TypeScriptErrorExtractor.GenerateValidationError(headerContent, httpClient);
        WriteTsFile(Path.Combine(errorsDir, "ValidationError.ts"), validationErrorContent, dryRun);

        // Generate barrel export for errors (not type-only, they are classes)
        var errorNames = new[] { "ApiError", "ValidationError" };
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, errorNames, isTypeOnly: false);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        WriteTsFile(Path.Combine(errorsDir, "index.ts"), barrelContent, dryRun);

        return 2;
    }

    /// <summary>
    /// Writes the ApiResult type file and its barrel export.
    /// </summary>
    private static int WriteApiResultType(
        string outputPath,
        string? headerContent,
        TypeScriptHttpClient httpClient,
        bool dryRun)
    {
        var typesDir = Path.Combine(outputPath, "types");

        var apiResultContent = TypeScriptApiResultExtractor.Generate(headerContent, httpClient);
        WriteTsFile(Path.Combine(typesDir, "ApiResult.ts"), apiResultContent, dryRun);

        // Generate barrel export for types
        var typeNames = new[] { "ApiResult" };
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, typeNames);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        WriteTsFile(Path.Combine(typesDir, "index.ts"), barrelContent, dryRun);

        return 1;
    }

    /// <summary>
    /// Writes client class files and their barrel export.
    /// </summary>
    private static int WriteClients(
        OpenApiDocument openApiDoc,
        string outputPath,
        string? headerContent,
        HashSet<string> enumNameSet,
        TypeScriptHttpClient httpClient,
        TypeScriptNamingStrategy namingStrategy,
        bool convertDates,
        bool dryRun)
    {
        var clients = TypeScriptClientExtractor.Extract(openApiDoc, headerContent, enumNameSet, namingStrategy);
        if (clients.Count == 0)
        {
            return 0;
        }

        var clientDir = Path.Combine(outputPath, "client");

        // Write base ApiClient (fetch or axios)
        var apiClientContent = httpClient == TypeScriptHttpClient.Axios
            ? TypeScriptAxiosApiClientExtractor.Generate(headerContent, convertDates)
            : TypeScriptFetchApiClientExtractor.Generate(headerContent, convertDates);
        WriteTsFile(Path.Combine(clientDir, "ApiClient.ts"), apiClientContent, dryRun);

        // Write per-segment client files
        var segmentClientNames = new List<string>();
        foreach (var (className, content) in clients)
        {
            var filePath = Path.Combine(clientDir, $"{className}.ts");
            WriteTsFile(filePath, content, dryRun);
            segmentClientNames.Add(className);
        }

        // Write ApiService root orchestrator
        var apiServiceContent = TypeScriptApiServiceExtractor.Generate(headerContent, segmentClientNames);
        WriteTsFile(Path.Combine(clientDir, "ApiService.ts"), apiServiceContent, dryRun);

        // Generate barrel export for client directory (not type-only, they are classes)
        var clientNames = new List<string> { "ApiClient" };
        clientNames.AddRange(segmentClientNames);
        clientNames.Add("ApiService");
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, clientNames, isTypeOnly: false);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        WriteTsFile(Path.Combine(clientDir, "index.ts"), barrelContent, dryRun);

        return clients.Count;
    }

    /// <summary>
    /// Writes React Query hook files (ApiProvider, useApiService, per-segment hooks) and their barrel export.
    /// </summary>
    private static int WriteReactQueryHooks(
        OpenApiDocument openApiDoc,
        string outputPath,
        string? headerContent,
        HashSet<string> enumNameSet,
        TypeScriptNamingStrategy namingStrategy,
        bool dryRun)
    {
        var hooks = TypeScriptReactQueryHookExtractor.Extract(openApiDoc, headerContent, enumNameSet, namingStrategy);
        if (hooks.Count == 0)
        {
            return 0;
        }

        var hooksDir = Path.Combine(outputPath, "hooks");

        // Write ApiProvider.ts
        var providerContent = TypeScriptApiProviderExtractor.GenerateApiProvider(headerContent);
        WriteTsFile(
            Path.Combine(hooksDir, "ApiProvider.ts"),
            providerContent,
            dryRun);

        // Write useApiService.ts
        var useApiServiceContent = TypeScriptApiProviderExtractor.GenerateUseApiService(headerContent);
        WriteTsFile(
            Path.Combine(hooksDir, "useApiService.ts"),
            useApiServiceContent,
            dryRun);

        // Write per-segment hook files
        var hookFileNames = new List<string> { "ApiProvider", "useApiService" };
        foreach (var (fileName, content) in hooks)
        {
            var filePath = Path.Combine(hooksDir, fileName + ".ts");
            WriteTsFile(filePath, content, dryRun);
            hookFileNames.Add(fileName);
        }

        // Generate barrel export (not type-only, they export functions)
        var barrelParams = TypeScriptBarrelExportExtractor.Create(headerContent, hookFileNames, isTypeOnly: false);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        WriteTsFile(
            Path.Combine(hooksDir, "index.ts"),
            barrelContent,
            dryRun);

        return hooks.Count;
    }

    /// <summary>
    /// Writes Zod validation schema files for enums, models, and array type aliases.
    /// </summary>
    private static int WriteZodSchemas(
        OpenApiDocument openApiDoc,
        string outputPath,
        string? headerContent,
        TypeScriptClientConfig config,
        HashSet<string> enumNameSet,
        bool dryRun)
    {
        var zodCount = 0;

        // Generate Zod enum schemas
        var zodEnums = TypeScriptZodEnumExtractor.Extract(openApiDoc, config);
        if (zodEnums.Count > 0)
        {
            var enumsDir = Path.Combine(outputPath, "enums");
            foreach (var (name, content) in zodEnums)
            {
                var filePath = Path.Combine(enumsDir, $"{name}.zod.ts");
                WriteTsFile(filePath, content, dryRun);
            }

            zodCount += zodEnums.Count;
        }

        // Generate Zod model schemas
        var zodModels = TypeScriptZodModelExtractor.Extract(openApiDoc, config, enumNameSet);
        if (zodModels.Count > 0)
        {
            var modelsDir = Path.Combine(outputPath, "models");
            foreach (var (name, content) in zodModels)
            {
                var filePath = Path.Combine(modelsDir, $"{name}.zod.ts");
                WriteTsFile(filePath, content, dryRun);
            }

            zodCount += zodModels.Count;
        }

        // Generate Zod array type alias schemas
        var zodArrays = TypeScriptZodModelExtractor.ExtractArrayTypeAliases(openApiDoc, config);
        if (zodArrays.Count > 0)
        {
            var modelsDir = Path.Combine(outputPath, "models");
            foreach (var (name, content) in zodArrays)
            {
                var filePath = Path.Combine(modelsDir, $"{name}.zod.ts");
                WriteTsFile(filePath, content, dryRun);
            }

            zodCount += zodArrays.Count;
        }

        return zodCount;
    }

    /// <summary>
    /// Writes the root barrel export (index.ts) that re-exports from subdirectories.
    /// </summary>
    private static void WriteRootBarrelExport(
        string outputPath,
        string? headerContent,
        List<string> subdirectories,
        bool dryRun)
    {
        var barrelParams = TypeScriptBarrelExportExtractor.CreateForSubdirectories(headerContent, subdirectories);
        var barrelGenerator = new GenerateContentForBarrelExport(barrelParams);
        var barrelContent = barrelGenerator.Generate();
        WriteTsFile(Path.Combine(outputPath, "index.ts"), barrelContent, dryRun);
    }

    /// <summary>
    /// Writes package.json and tsconfig.json scaffold files.
    /// </summary>
    private static bool WritePackageScaffold(
        OpenApiDocument openApiDoc,
        string outputPath,
        TypeScriptClientConfig config,
        bool dryRun)
    {
        var packageName = config.PackageName
            ?? TypeScriptPackageScaffoldExtractor.DerivePackageName(openApiDoc.Info?.Title ?? string.Empty);

        var description = openApiDoc.Info?.Description;

        var packageJsonContent = TypeScriptPackageScaffoldExtractor.GeneratePackageJson(
            packageName,
            config.PackageVersion,
            description,
            config);
        WriteJsonFile(Path.Combine(outputPath, "package.json"), packageJsonContent, dryRun);

        var tsConfigContent = TypeScriptPackageScaffoldExtractor.GenerateTsConfig();
        WriteJsonFile(Path.Combine(outputPath, "tsconfig.json"), tsConfigContent, dryRun);

        return true;
    }

    /// <summary>
    /// Writes a TypeScript file, skipping the actual write when dry-run is active.
    /// </summary>
    private static void WriteTsFile(
        string filePath,
        string content,
        bool dryRun)
    {
        if (dryRun)
        {
            return;
        }

        CodeGeneration.TypeScript.Helpers.FileHelper.WriteTsFile(filePath, content);
    }

    /// <summary>
    /// Writes a JSON file with UTF-8 encoding (no BOM), skipping the actual write when dry-run is active.
    /// </summary>
    private static void WriteJsonFile(
        string filePath,
        string content,
        bool dryRun)
    {
        if (dryRun)
        {
            return;
        }

        var directory = Path.GetDirectoryName(filePath);
        if (directory != null && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        File.WriteAllText(filePath, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
    }
}