// <auto-generated />
import { ApiError } from '../errors/ApiError';
import { ValidationError } from '../errors/ValidationError';
import type { ApiResult } from '../types/ApiResult';

export type FetchRequestInterceptor = (url: string, init: RequestInit) => RequestInit | Promise<RequestInit>;
export type FetchResponseInterceptor = (response: Response) => Response | Promise<Response>;

export interface ApiClientOptions {
  getAccessToken?: () => string | Promise<string>;
  defaultHeaders?: Record<string, string>;
  requestInterceptors?: FetchRequestInterceptor[];
  responseInterceptors?: FetchResponseInterceptor[];
}

export interface RequestOptions {
  body?: unknown;
  query?: Record<string, string | number | boolean | undefined>;
  headers?: Record<string, string>;
  signal?: AbortSignal;
  responseType?: 'json' | 'blob';
}

export class ApiClient {
  private readonly baseUrl: string;
  private readonly options: ApiClientOptions;

  constructor(baseUrl: string, options?: ApiClientOptions) {
    this.baseUrl = baseUrl.replace(/\/+$/, '');
    this.options = options ?? {};
  }

  async request<T>(method: string, path: string, options?: RequestOptions): Promise<ApiResult<T>> {
    const url = this.buildUrl(path, options?.query);
    const headers = await this.getHeaders(options?.headers);

    let fetchBody: BodyInit | undefined;
    if (options?.body !== undefined) {
      if (options.body instanceof FormData) {
        fetchBody = options.body;
      } else if (options.body instanceof Blob) {
        headers.set('Content-Type', 'application/octet-stream');
        fetchBody = options.body;
      } else {
        headers.set('Content-Type', 'application/json');
        fetchBody = JSON.stringify(options.body);
      }
    }

    let init: RequestInit = {
      method,
      headers,
      body: fetchBody,
      signal: options?.signal,
    };

    for (const interceptor of this.options.requestInterceptors ?? []) {
      init = await interceptor(url, init);
    }

    let response = await fetch(url, init);

    for (const interceptor of this.options.responseInterceptors ?? []) {
      response = await interceptor(response);
    }

    return this.handleResponse<T>(response, options?.responseType);
  }

  async *requestStream<T>(method: string, path: string, options?: RequestOptions): AsyncGenerator<T> {
    const url = this.buildUrl(path, options?.query);
    const headers = await this.getHeaders(options?.headers);

    let init: RequestInit = {
      method,
      headers,
      signal: options?.signal,
    };

    for (const interceptor of this.options.requestInterceptors ?? []) {
      init = await interceptor(url, init);
    }

    const response = await fetch(url, init);

    if (!response.ok) {
      const result = await this.handleResponse<T>(response);
      if ('error' in result) {
        throw result.error;
      }
      throw new ApiError(response.status, response.statusText, 'Stream request failed', response);
    }

    const reader = response.body?.getReader();
    if (!reader) {
      throw new ApiError(0, 'NoBody', 'Response body is empty', response);
    }

    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() ?? '';

        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.length === 0) continue;
          yield JSON.parse(trimmed) as T;
        }
      }

      if (buffer.trim().length > 0) {
        yield JSON.parse(buffer.trim()) as T;
      }
    } finally {
      reader.releaseLock();
    }
  }

  buildUrl(path: string, query?: Record<string, string | number | boolean | undefined>): string {
    const url = new URL(`${this.baseUrl}${path}`);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        if (value !== undefined) {
          url.searchParams.set(key, String(value));
        }
      }
    }
    return url.toString();
  }

  async getHeaders(extra?: Record<string, string>): Promise<Headers> {
    const headers = new Headers(this.options.defaultHeaders);

    if (this.options.getAccessToken) {
      const token = await this.options.getAccessToken();
      headers.set('Authorization', `Bearer ${token}`);
    }

    if (extra) {
      for (const [key, value] of Object.entries(extra)) {
        headers.set(key, value);
      }
    }

    return headers;
  }

  private async handleResponse<T>(response: Response, responseType?: 'json' | 'blob'): Promise<ApiResult<T>> {
    if (response.status === 204) {
      return { status: 'noContent', response };
    }

    const contentType = response.headers.get('Content-Type') ?? '';
    const isJson = responseType ? responseType === 'json' : contentType.includes('application/json');

    if (response.ok) {
      const data = isJson ? await response.json() : await response.blob();
      const status = response.status === 201 ? 'created' as const : 'ok' as const;
      return { status, data: data as T, response };
    }

    const errorBody = isJson ? await response.json() : null;
    const message = errorBody?.title ?? errorBody?.message ?? response.statusText;

    if (response.status === 400 && errorBody?.errors) {
      return {
        status: 'badRequest',
        error: new ValidationError(response.status, response.statusText, message, errorBody.errors, response),
        response,
      };
    }

    const apiError = new ApiError(response.status, response.statusText, message, response);

    switch (response.status) {
      case 401:
        return { status: 'unauthorized', error: apiError, response };
      case 404:
        return { status: 'notFound', error: apiError, response };
      case 409:
        return { status: 'conflict', error: apiError, response };
      default:
        return { status: 'serverError', error: apiError, response };
    }
  }
}